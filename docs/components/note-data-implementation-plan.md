# ãƒãƒ¼ãƒ„ãƒ‡ãƒ¼ã‚¿ å®Ÿè£…è¨ˆç”»æ›¸

## å®Ÿè£…æ¦‚è¦

æœ¬æ›¸ã¯ã€Jirouãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ãƒãƒ¼ãƒ„ãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼ˆNoteDataã€ChartDataï¼‰ã®æ®µéšçš„ãªå®Ÿè£…è¨ˆç”»ã‚’å®šç¾©ã—ã¾ã™ã€‚å¥¥è¡Œãå‹ãƒªã‚ºãƒ ã‚²ãƒ¼ãƒ ã®ç‰¹æ€§ã‚’è€ƒæ…®ã—ã€åŠ¹ç‡çš„ãªãƒ‡ãƒ¼ã‚¿ç®¡ç†ã¨é«˜ã„ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã‚’å®Ÿç¾ã™ã‚‹å®Ÿè£…ã‚’ç›®æŒ‡ã—ã¾ã™ã€‚

### ğŸ“Š å®Ÿè£…é€²æ—çŠ¶æ³ï¼ˆ2025å¹´8æœˆ15æ—¥æ›´æ–°ï¼‰

**å®Œäº†ç‡**: 100% (å…¨é …ç›® 8/8 å®Œäº†) ğŸ‰ğŸ‰ğŸ‰

#### âœ… å®Ÿè£…å®Œäº†é …ç›®
- **NoteData.cs** - åŸºæœ¬ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã®å®Œå…¨å®Ÿè£… âœ…
- **ChartData.cs** - ScriptableObjectã«ã‚ˆã‚‹è­œé¢ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  âœ…
- **ChartStatistics.cs** - çµ±è¨ˆæƒ…å ±ã‚¯ãƒ©ã‚¹ï¼ˆChartDataå†…ã«çµ±åˆæ¸ˆã¿ï¼‰ âœ…
- **NotePositionHelper.cs** - 3Dåº§æ¨™è¨ˆç®—ãƒ˜ãƒ«ãƒ‘ãƒ¼å®Œå…¨å®Ÿè£… âœ…
- **NotePoolManager.cs** - ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ç”¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«å®Œå…¨å®Ÿè£… âœ…
- **åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸** - EditMode/PlayModeãƒ†ã‚¹ãƒˆå……å®Ÿ âœ…
- **ChartDataEditor.cs** - Unity Editoræ‹¡å¼µï¼ˆã‚«ã‚¹ã‚¿ãƒ ã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼ï¼‰ âœ…
- **ChartEditorWindow.cs** - è­œé¢ç·¨é›†ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ï¼ˆJSONã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ/ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½ä»˜ãï¼‰ âœ…

**æ³¨è¨˜**: ã™ã¹ã¦ã®å®Ÿè£…é …ç›®ãŒå®Œäº†ã—ã€ãƒãƒ¼ãƒ„ãƒ‡ãƒ¼ã‚¿ã‚·ã‚¹ãƒ†ãƒ ã¯å®Œå…¨ã«å®Ÿè£…ã•ã‚Œã¾ã—ãŸã€‚

## å®Ÿè£…ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

### å…¨ä½“ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆ2é€±é–“ï¼‰

| é€± | ãƒ•ã‚§ãƒ¼ã‚º | ä¸»è¦ã‚¿ã‚¹ã‚¯ |
|---|---------|-----------|
| ç¬¬1é€± | åŸºç¤å®Ÿè£… | ãƒ‡ãƒ¼ã‚¿æ§‹é€ å®šç¾©ã€ScriptableObjectä½œæˆã€åŸºæœ¬ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè£… |
| ç¬¬2é€± | æ©Ÿèƒ½æ‹¡å¼µãƒ»æœ€é©åŒ– | ã‚¨ãƒ‡ã‚£ã‚¿æ‹¡å¼µã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ã€ãƒ†ã‚¹ãƒˆå®Ÿè£… |

## å®Ÿè£…ãƒ•ã‚§ãƒ¼ã‚ºè©³ç´°

### ãƒ•ã‚§ãƒ¼ã‚º1: åŸºæœ¬ãƒ‡ãƒ¼ã‚¿æ§‹é€ ï¼ˆDay 1-2ï¼‰

#### Day 1: NoteDataã‚¯ãƒ©ã‚¹ã®å®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/_Jirou/Scripts/Core/NoteData.cs`

```csharp
using System;
using UnityEngine;

namespace Jirou.Core
{
    /// <summary>
    /// ãƒãƒ¼ãƒ„ã‚¿ã‚¤ãƒ—ã®åˆ—æŒ™å‹
    /// </summary>
    [Serializable]
    public enum NoteType
    {
        Tap = 0,    // å˜æŠ¼ã—ãƒãƒ¼ãƒ„
        Hold = 1    // é•·æŠ¼ã—ãƒãƒ¼ãƒ„
    }

    /// <summary>
    /// å€‹åˆ¥ã®ãƒãƒ¼ãƒ„ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚¯ãƒ©ã‚¹
    /// </summary>
    [Serializable]
    public class NoteData
    {
        [Header("åŸºæœ¬æƒ…å ±")]
        [Tooltip("ãƒãƒ¼ãƒ„ã®ç¨®é¡")]
        public NoteType noteType = NoteType.Tap;
        
        [Tooltip("ãƒ¬ãƒ¼ãƒ³ç•ªå·ï¼ˆ0-3ï¼‰")]
        [Range(0, 3)]
        public int laneIndex = 0;
        
        [Tooltip("ãƒ’ãƒƒãƒˆã‚¿ã‚¤ãƒŸãƒ³ã‚°ï¼ˆãƒ“ãƒ¼ãƒˆå˜ä½ï¼‰")]
        [Min(0f)]
        public float timeToHit = 0f;
        
        [Header("Holdãƒãƒ¼ãƒ„å°‚ç”¨")]
        [Tooltip("Holdãƒãƒ¼ãƒ„ã®é•·ã•ï¼ˆãƒ“ãƒ¼ãƒˆå˜ä½ï¼‰")]
        [Min(0f)]
        public float holdDuration = 0f;
        
        [Header("è¦–è¦šèª¿æ•´")]
        [Tooltip("ãƒãƒ¼ãƒ„ã®å¤§ãã•å€ç‡")]
        [Range(0.5f, 2.0f)]
        public float visualScale = 1.0f;
        
        [Tooltip("ãƒãƒ¼ãƒ„ã®è‰²")]
        public Color noteColor = Color.white;
        
        [Header("ã‚ªãƒ—ã‚·ãƒ§ãƒ³")]
        [Tooltip("ã‚«ã‚¹ã‚¿ãƒ ãƒ’ãƒƒãƒˆéŸ³")]
        public AudioClip customHitSound;
        
        [Tooltip("ã‚«ã‚¹ã‚¿ãƒ ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆ")]
        public GameObject customHitEffect;
        
        [Tooltip("åŸºæœ¬ã‚¹ã‚³ã‚¢å€¤")]
        [Min(1)]
        public int baseScore = 100;
        
        [Tooltip("ã‚¹ã‚³ã‚¢å€ç‡")]
        [Range(0.1f, 10f)]
        public float scoreMultiplier = 1.0f;
        
        // é™çš„å®šæ•°
        public static readonly float[] LaneXPositions = { -3f, -1f, 1f, 3f };
        public static readonly KeyCode[] LaneKeys = 
        { 
            KeyCode.D, 
            KeyCode.F, 
            KeyCode.J, 
            KeyCode.K 
        };
        
        /// <summary>
        /// ãƒ¬ãƒ¼ãƒ³ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰Xåº§æ¨™ã‚’å–å¾—
        /// </summary>
        public float GetLaneXPosition()
        {
            if (laneIndex >= 0 && laneIndex < LaneXPositions.Length)
            {
                return LaneXPositions[laneIndex];
            }
            Debug.LogWarning($"ç„¡åŠ¹ãªãƒ¬ãƒ¼ãƒ³ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: {laneIndex}");
            return 0f;
        }
        
        /// <summary>
        /// ãƒãƒ¼ãƒ„ã®çµ‚äº†ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’å–å¾—ï¼ˆHoldãƒãƒ¼ãƒ„ç”¨ï¼‰
        /// </summary>
        public float GetEndTime()
        {
            return noteType == NoteType.Hold ? timeToHit + holdDuration : timeToHit;
        }
        
        /// <summary>
        /// ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯
        /// </summary>
        public bool Validate(out string error)
        {
            error = "";
            
            if (laneIndex < 0 || laneIndex > 3)
            {
                error = $"ç„¡åŠ¹ãªãƒ¬ãƒ¼ãƒ³ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: {laneIndex}";
                return false;
            }
            
            if (timeToHit < 0)
            {
                error = $"è² ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°å€¤: {timeToHit}";
                return false;
            }
            
            if (noteType == NoteType.Hold && holdDuration <= 0)
            {
                error = $"Holdãƒãƒ¼ãƒ„ã®é•·ã•ãŒä¸æ­£: {holdDuration}";
                return false;
            }
            
            if (visualScale <= 0)
            {
                error = $"ä¸æ­£ãªã‚¹ã‚±ãƒ¼ãƒ«å€¤: {visualScale}";
                return false;
            }
            
            return true;
        }
    }
}
```

**æ¤œè¨¼é …ç›®**:
- [ ] ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ãªã—
- [ ] Inspectorã§å„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãŒç·¨é›†å¯èƒ½
- [ ] Rangeå±æ€§ãŒæ­£ã—ãæ©Ÿèƒ½
- [ ] Validate()ãƒ¡ã‚½ãƒƒãƒ‰ãŒæ­£ã—ãã‚¨ãƒ©ãƒ¼ã‚’æ¤œå‡º

#### Day 2: ChartDataã®ScriptableObjectå®Ÿè£…

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/_Jirou/Scripts/Core/ChartData.cs`

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

namespace Jirou.Core
{
    /// <summary>
    /// è­œé¢ãƒ‡ãƒ¼ã‚¿ã‚’ç®¡ç†ã™ã‚‹ScriptableObject
    /// </summary>
    [CreateAssetMenu(fileName = "NewChart", menuName = "Jirou/Chart Data", order = 1)]
    public class ChartData : ScriptableObject
    {
        [Header("æ¥½æ›²æƒ…å ±")]
        [Tooltip("æ¥½æ›²ãƒ•ã‚¡ã‚¤ãƒ«")]
        public AudioClip songClip;
        
        [Tooltip("BPMï¼ˆBeats Per Minuteï¼‰")]
        [Range(60f, 300f)]
        public float bpm = 120f;
        
        [Tooltip("æ›²å")]
        public string songName = "ç„¡é¡Œ";
        
        [Tooltip("ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆå")]
        public string artist = "ä¸æ˜";
        
        [Tooltip("ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼é–‹å§‹æ™‚é–“ï¼ˆç§’ï¼‰")]
        [Min(0f)]
        public float previewTime = 0f;
        
        [Tooltip("æœ€åˆã®ãƒ“ãƒ¼ãƒˆã¾ã§ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼ˆç§’ï¼‰")]
        public float firstBeatOffset = 0f;
        
        [Header("é›£æ˜“åº¦æƒ…å ±")]
        [Tooltip("é›£æ˜“åº¦ãƒ¬ãƒ™ãƒ«ï¼ˆ1-10ï¼‰")]
        [Range(1, 10)]
        public int difficulty = 1;
        
        [Tooltip("é›£æ˜“åº¦å")]
        public string difficultyName = "Normal";
        
        [Header("è­œé¢ãƒ‡ãƒ¼ã‚¿")]
        [Tooltip("ãƒãƒ¼ãƒ„ãƒªã‚¹ãƒˆ")]
        public List<NoteData> notes = new List<NoteData>();
        
        [Header("ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿")]
        [Tooltip("è­œé¢ä½œæˆè€…")]
        public string chartAuthor = "";
        
        [Tooltip("è­œé¢ãƒãƒ¼ã‚¸ãƒ§ãƒ³")]
        public string chartVersion = "1.0";
        
        [Tooltip("ä½œæˆæ—¥æ™‚")]
        public string createdDate = "";
        
        [Tooltip("æœ€çµ‚æ›´æ–°æ—¥æ™‚")]
        public string lastModified = "";
        
        // å®Ÿè£…ã¯æ¬¡ã®ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã§è¿½åŠ 
    }
}
```

### ãƒ•ã‚§ãƒ¼ã‚º2: ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè£…ï¼ˆDay 3-4ï¼‰

#### Day 3: ChartDataã®åŸºæœ¬ãƒ¡ã‚½ãƒƒãƒ‰

**è¿½åŠ å®Ÿè£…å†…å®¹**:

```csharp
public class ChartData : ScriptableObject
{
    // ... æ—¢å­˜ã®ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ ...
    
    /// <summary>
    /// ãƒãƒ¼ãƒ„ã‚’ã‚¿ã‚¤ãƒŸãƒ³ã‚°é †ã«ã‚½ãƒ¼ãƒˆ
    /// </summary>
    public void SortNotesByTime()
    {
        notes.Sort((a, b) => a.timeToHit.CompareTo(b.timeToHit));
        
        #if UNITY_EDITOR
        UnityEditor.EditorUtility.SetDirty(this);
        #endif
        
        Debug.Log($"[ChartData] {notes.Count}å€‹ã®ãƒãƒ¼ãƒ„ã‚’ã‚½ãƒ¼ãƒˆã—ã¾ã—ãŸ");
    }
    
    /// <summary>
    /// æŒ‡å®šç¯„å›²ã®ãƒãƒ¼ãƒ„ã‚’å–å¾—
    /// </summary>
    public List<NoteData> GetNotesInTimeRange(float startBeat, float endBeat)
    {
        return notes.FindAll(n => 
            n.timeToHit >= startBeat && 
            n.timeToHit <= endBeat);
    }
    
    /// <summary>
    /// ãƒ¬ãƒ¼ãƒ³åˆ¥ã®ãƒãƒ¼ãƒ„æ•°ã‚’å–å¾—
    /// </summary>
    public int[] GetNoteCountByLane()
    {
        int[] counts = new int[4];
        foreach (var note in notes)
        {
            if (note.laneIndex >= 0 && note.laneIndex < 4)
            {
                counts[note.laneIndex]++;
            }
        }
        return counts;
    }
    
    /// <summary>
    /// ç·ãƒãƒ¼ãƒ„æ•°ã‚’å–å¾—
    /// </summary>
    public int GetTotalNoteCount()
    {
        return notes.Count;
    }
    
    /// <summary>
    /// Holdãƒãƒ¼ãƒ„ã®æ•°ã‚’å–å¾—
    /// </summary>
    public int GetHoldNoteCount()
    {
        return notes.Count(n => n.noteType == NoteType.Hold);
    }
    
    /// <summary>
    /// Tapãƒãƒ¼ãƒ„ã®æ•°ã‚’å–å¾—
    /// </summary>
    public int GetTapNoteCount()
    {
        return notes.Count(n => n.noteType == NoteType.Tap);
    }
    
    /// <summary>
    /// è­œé¢ã®é•·ã•ï¼ˆãƒ“ãƒ¼ãƒˆï¼‰ã‚’å–å¾—
    /// </summary>
    public float GetChartLengthInBeats()
    {
        if (notes.Count == 0) return 0f;
        
        float lastBeat = notes.Max(n => n.GetEndTime());
        return lastBeat;
    }
    
    /// <summary>
    /// è­œé¢ã®é•·ã•ï¼ˆç§’ï¼‰ã‚’å–å¾—
    /// </summary>
    public float GetChartLengthInSeconds()
    {
        if (bpm <= 0) return 0f;
        return GetChartLengthInBeats() * (60f / bpm);
    }
    
    /// <summary>
    /// æ¥½æ›²ã®é•·ã•ï¼ˆç§’ï¼‰ã‚’å–å¾—
    /// </summary>
    public float GetSongLengthInSeconds()
    {
        if (songClip == null) return 0f;
        return songClip.length;
    }
}
```

**æ¤œè¨¼é …ç›®**:
- [ ] å„ãƒ¡ã‚½ãƒƒãƒ‰ãŒæ­£ã—ã„å€¤ã‚’è¿”ã™
- [ ] ã‚¨ãƒ©ãƒ¼ã‚±ãƒ¼ã‚¹ã®å‡¦ç†ãŒé©åˆ‡
- [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒè‰¯å¥½ï¼ˆ1000ãƒãƒ¼ãƒ„ã§1msä»¥å†…ï¼‰

#### Day 4: ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã¨ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½

**è¿½åŠ å®Ÿè£…å†…å®¹**:

```csharp
public class ChartData : ScriptableObject
{
    // ... æ—¢å­˜ã®ãƒ¡ã‚½ãƒƒãƒ‰ ...
    
    /// <summary>
    /// è­œé¢ãƒ‡ãƒ¼ã‚¿ã®å¦¥å½“æ€§ã‚’ãƒã‚§ãƒƒã‚¯
    /// </summary>
    public bool ValidateChart(out List<string> errors)
    {
        errors = new List<string>();
        bool isValid = true;
        
        // BPMãƒã‚§ãƒƒã‚¯
        if (bpm <= 0 || bpm > 999)
        {
            errors.Add($"ä¸æ­£ãªBPMå€¤: {bpm}");
            isValid = false;
        }
        
        // æ¥½æ›²ãƒ•ã‚¡ã‚¤ãƒ«ãƒã‚§ãƒƒã‚¯
        if (songClip == null)
        {
            errors.Add("æ¥½æ›²ãƒ•ã‚¡ã‚¤ãƒ«ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“");
            isValid = false;
        }
        
        // æ›²åãƒã‚§ãƒƒã‚¯
        if (string.IsNullOrEmpty(songName))
        {
            errors.Add("æ›²åãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“");
            isValid = false;
        }
        
        // ãƒãƒ¼ãƒ„ãƒ‡ãƒ¼ã‚¿ãƒã‚§ãƒƒã‚¯
        HashSet<string> duplicateCheck = new HashSet<string>();
        
        for (int i = 0; i < notes.Count; i++)
        {
            var note = notes[i];
            string noteError;
            
            // å€‹åˆ¥ãƒãƒ¼ãƒ„ã®ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
            if (!note.Validate(out noteError))
            {
                errors.Add($"ãƒãƒ¼ãƒ„[{i}]: {noteError}");
                isValid = false;
            }
            
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯ï¼ˆåŒã˜ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã€åŒã˜ãƒ¬ãƒ¼ãƒ³ï¼‰
            string key = $"{note.laneIndex}_{note.timeToHit:F3}";
            if (duplicateCheck.Contains(key))
            {
                errors.Add($"ãƒãƒ¼ãƒ„[{i}]: é‡è¤‡ãƒãƒ¼ãƒ„ï¼ˆãƒ¬ãƒ¼ãƒ³{note.laneIndex}, ã‚¿ã‚¤ãƒŸãƒ³ã‚°{note.timeToHit:F2}ï¼‰");
                isValid = false;
            }
            duplicateCheck.Add(key);
        }
        
        // è­œé¢é•·ãƒã‚§ãƒƒã‚¯
        float chartLength = GetChartLengthInSeconds();
        float songLength = GetSongLengthInSeconds();
        
        if (songLength > 0 && chartLength > songLength + 5f)
        {
            errors.Add($"è­œé¢ãŒæ¥½æ›²ã‚ˆã‚Šé•·ã™ãã¾ã™ï¼ˆè­œé¢: {chartLength:F1}ç§’, æ¥½æ›²: {songLength:F1}ç§’ï¼‰");
            isValid = false;
        }
        
        return isValid;
    }
    
    /// <summary>
    /// è­œé¢ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—
    /// </summary>
    public ChartStatistics GetStatistics()
    {
        var stats = new ChartStatistics();
        
        stats.totalNotes = GetTotalNoteCount();
        stats.tapNotes = GetTapNoteCount();
        stats.holdNotes = GetHoldNoteCount();
        stats.notesByLane = GetNoteCountByLane();
        stats.chartLengthBeats = GetChartLengthInBeats();
        stats.chartLengthSeconds = GetChartLengthInSeconds();
        stats.averageNPS = stats.totalNotes / Mathf.Max(1f, stats.chartLengthSeconds);
        
        // å¯†åº¦è¨ˆç®—
        if (notes.Count > 1)
        {
            float totalInterval = 0f;
            for (int i = 1; i < notes.Count; i++)
            {
                totalInterval += Mathf.Abs(notes[i].timeToHit - notes[i - 1].timeToHit);
            }
            stats.averageInterval = totalInterval / (notes.Count - 1);
        }
        
        return stats;
    }
    
    /// <summary>
    /// ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’å‡ºåŠ›
    /// </summary>
    public void PrintDebugInfo()
    {
        Debug.Log("=== Chart Debug Info ===");
        Debug.Log($"æ›²å: {songName}");
        Debug.Log($"ã‚¢ãƒ¼ãƒ†ã‚£ã‚¹ãƒˆ: {artist}");
        Debug.Log($"BPM: {bpm}");
        Debug.Log($"é›£æ˜“åº¦: {difficultyName} (Lv.{difficulty})");
        
        var stats = GetStatistics();
        Debug.Log($"ç·ãƒãƒ¼ãƒ„æ•°: {stats.totalNotes}");
        Debug.Log($"Tap: {stats.tapNotes}, Hold: {stats.holdNotes}");
        Debug.Log($"ãƒ¬ãƒ¼ãƒ³åˆ†å¸ƒ: [{string.Join(", ", stats.notesByLane)}]");
        Debug.Log($"è­œé¢é•·: {stats.chartLengthSeconds:F1}ç§’ ({stats.chartLengthBeats:F1}ãƒ“ãƒ¼ãƒˆ)");
        Debug.Log($"å¹³å‡NPS: {stats.averageNPS:F2}");
        Debug.Log("========================");
    }
}

/// <summary>
/// è­œé¢çµ±è¨ˆæƒ…å ±
/// </summary>
[Serializable]
public class ChartStatistics
{
    public int totalNotes;
    public int tapNotes;
    public int holdNotes;
    public int[] notesByLane;
    public float chartLengthBeats;
    public float chartLengthSeconds;
    public float averageNPS;  // Notes Per Second
    public float averageInterval;  // ãƒ“ãƒ¼ãƒˆå˜ä½
}
```

### ãƒ•ã‚§ãƒ¼ã‚º3: ãƒ˜ãƒ«ãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹ã¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼ˆDay 5-6ï¼‰

#### Day 5: 3Dä½ç½®è¨ˆç®—ãƒ˜ãƒ«ãƒ‘ãƒ¼

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/_Jirou/Scripts/Core/NotePositionHelper.cs`

```csharp
using UnityEngine;

namespace Jirou.Core
{
    /// <summary>
    /// ãƒãƒ¼ãƒ„ã®3Dä½ç½®ã‚’è¡¨ã™æ§‹é€ ä½“
    /// </summary>
    [System.Serializable]
    public struct NotePosition3D
    {
        public float x;  // ãƒ¬ãƒ¼ãƒ³ä½ç½®
        public float y;  // é«˜ã•
        public float z;  // å¥¥è¡Œãä½ç½®
        
        /// <summary>
        /// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
        /// </summary>
        public NotePosition3D(int laneIndex, float zPosition, float yPosition = 0.5f)
        {
            if (laneIndex >= 0 && laneIndex < NoteData.LaneXPositions.Length)
            {
                x = NoteData.LaneXPositions[laneIndex];
            }
            else
            {
                x = 0f;
                Debug.LogWarning($"ç„¡åŠ¹ãªãƒ¬ãƒ¼ãƒ³ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹: {laneIndex}");
            }
            
            y = yPosition;
            z = zPosition;
        }
        
        /// <summary>
        /// Unity Vector3ã¸ã®å¤‰æ›
        /// </summary>
        public Vector3 ToVector3()
        {
            return new Vector3(x, y, z);
        }
        
        /// <summary>
        /// åˆ¤å®šãƒ©ã‚¤ãƒ³ã¾ã§ã®è·é›¢ã‚’å–å¾—
        /// </summary>
        public float GetDistanceToJudgmentLine(float judgmentZ = 0f)
        {
            return Mathf.Abs(z - judgmentZ);
        }
    }
    
    /// <summary>
    /// ãƒãƒ¼ãƒ„ã®è¦–è¦šè¨ˆç®—ãƒ˜ãƒ«ãƒ‘ãƒ¼
    /// </summary>
    public static class NoteVisualCalculator
    {
        /// <summary>
        /// è·é›¢ã«åŸºã¥ãã‚¹ã‚±ãƒ¼ãƒ«è¨ˆç®—
        /// </summary>
        public static float CalculateScaleByDistance(float currentZ, float spawnZ, float baseScale = 1.0f)
        {
            if (spawnZ <= 0) return baseScale;
            
            // å¥¥ï¼ˆspawnZï¼‰ã§0.5å€ã€æ‰‹å‰ï¼ˆ0ï¼‰ã§1.5å€ã«ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°
            float distanceRatio = Mathf.Clamp01(currentZ / spawnZ);
            float scaleFactor = Mathf.Lerp(1.5f, 0.5f, distanceRatio);
            
            return baseScale * scaleFactor;
        }
        
        /// <summary>
        /// è·é›¢ã«åŸºã¥ãé€æ˜åº¦è¨ˆç®—ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³åŠ¹æœï¼‰
        /// </summary>
        public static float CalculateAlphaByDistance(float currentZ, float spawnZ, float fadeStartRatio = 0.8f)
        {
            if (spawnZ <= 0) return 1f;
            
            float fadeStartZ = spawnZ * fadeStartRatio;
            
            if (currentZ > fadeStartZ)
            {
                float fadeRatio = (currentZ - fadeStartZ) / (spawnZ - fadeStartZ);
                return 1f - fadeRatio;
            }
            
            return 1f;
        }
        
        /// <summary>
        /// ãƒãƒ¼ãƒ„ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’è¨ˆç®—
        /// </summary>
        public static Vector3 CalculateNoteWorldPosition(NoteData noteData, float currentBeat, Conductor conductor)
        {
            if (conductor == null)
            {
                Debug.LogError("ConductorãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“");
                return Vector3.zero;
            }
            
            float zPosition = conductor.GetNoteZPosition(noteData.timeToHit);
            var position = new NotePosition3D(noteData.laneIndex, zPosition);
            
            return position.ToVector3();
        }
        
        /// <summary>
        /// Holdãƒãƒ¼ãƒ„ã®çµ‚ç«¯ä½ç½®ã‚’è¨ˆç®—
        /// </summary>
        public static Vector3 CalculateHoldEndPosition(NoteData noteData, Conductor conductor)
        {
            if (noteData.noteType != NoteType.Hold)
            {
                Debug.LogWarning("Holdãƒãƒ¼ãƒ„ã§ã¯ãªã„ãŸã‚CalculateHoldEndPositionã‚’ã‚¹ã‚­ãƒƒãƒ—");
                return Vector3.zero;
            }
            
            float endBeat = noteData.timeToHit + noteData.holdDuration;
            float zPosition = conductor.GetNoteZPosition(endBeat);
            var position = new NotePosition3D(noteData.laneIndex, zPosition);
            
            return position.ToVector3();
        }
    }
}
```

#### Day 6: ãƒãƒ¼ãƒ„ãƒ—ãƒ¼ãƒ«ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/_Jirou/Scripts/Core/NotePoolManager.cs`

```csharp
using System.Collections.Generic;
using UnityEngine;

namespace Jirou.Core
{
    /// <summary>
    /// ãƒãƒ¼ãƒ„ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«ç®¡ç†
    /// </summary>
    public class NotePoolManager : MonoBehaviour
    {
        [Header("ãƒ—ãƒ¬ãƒãƒ–è¨­å®š")]
        [SerializeField] private GameObject tapNotePrefab;
        [SerializeField] private GameObject holdNotePrefab;
        
        [Header("ãƒ—ãƒ¼ãƒ«è¨­å®š")]
        [SerializeField] private int initialPoolSize = 50;
        [SerializeField] private int maxPoolSize = 200;
        
        private Queue<GameObject> tapNotePool = new Queue<GameObject>();
        private Queue<GameObject> holdNotePool = new Queue<GameObject>();
        private Transform poolContainer;
        
        private static NotePoolManager instance;
        public static NotePoolManager Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = FindObjectOfType<NotePoolManager>();
                }
                return instance;
            }
        }
        
        void Awake()
        {
            instance = this;
            InitializePool();
        }
        
        /// <summary>
        /// ãƒ—ãƒ¼ãƒ«ã‚’åˆæœŸåŒ–
        /// </summary>
        private void InitializePool()
        {
            // ãƒ—ãƒ¼ãƒ«ã‚³ãƒ³ãƒ†ãƒŠã‚’ä½œæˆ
            GameObject container = new GameObject("NotePool");
            container.transform.SetParent(transform);
            poolContainer = container.transform;
            
            // åˆæœŸãƒ—ãƒ¼ãƒ«ã‚’ç”Ÿæˆ
            for (int i = 0; i < initialPoolSize; i++)
            {
                CreatePooledNote(NoteType.Tap);
                
                if (i < initialPoolSize / 2)  // Holdãƒãƒ¼ãƒ„ã¯åŠåˆ†ã®æ•°
                {
                    CreatePooledNote(NoteType.Hold);
                }
            }
            
            Debug.Log($"[NotePool] åˆæœŸåŒ–å®Œäº† - Tap: {tapNotePool.Count}, Hold: {holdNotePool.Count}");
        }
        
        /// <summary>
        /// ãƒ—ãƒ¼ãƒ«ç”¨ã®ãƒãƒ¼ãƒ„ã‚’ä½œæˆ
        /// </summary>
        private GameObject CreatePooledNote(NoteType type)
        {
            GameObject prefab = type == NoteType.Tap ? tapNotePrefab : holdNotePrefab;
            
            if (prefab == null)
            {
                Debug.LogError($"ãƒ—ãƒ¬ãƒãƒ–ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“: {type}");
                return null;
            }
            
            GameObject note = Instantiate(prefab, poolContainer);
            note.SetActive(false);
            
            Queue<GameObject> pool = type == NoteType.Tap ? tapNotePool : holdNotePool;
            pool.Enqueue(note);
            
            return note;
        }
        
        /// <summary>
        /// ãƒ—ãƒ¼ãƒ«ã‹ã‚‰ãƒãƒ¼ãƒ„ã‚’å–å¾—
        /// </summary>
        public GameObject GetNote(NoteType type)
        {
            Queue<GameObject> pool = type == NoteType.Tap ? tapNotePool : holdNotePool;
            
            GameObject note = null;
            
            // ãƒ—ãƒ¼ãƒ«ã‹ã‚‰å–å¾—ã‚’è©¦ã¿ã‚‹
            while (pool.Count > 0)
            {
                note = pool.Dequeue();
                
                if (note != null)
                {
                    note.SetActive(true);
                    return note;
                }
            }
            
            // ãƒ—ãƒ¼ãƒ«ãŒç©ºã®å ´åˆã¯æ–°è¦ä½œæˆ
            note = CreatePooledNote(type);
            
            if (note != null)
            {
                pool.Dequeue();  // ä½œæˆæ™‚ã«ã‚­ãƒ¥ãƒ¼ã«è¿½åŠ ã•ã‚Œã‚‹ãŸã‚å–ã‚Šå‡ºã™
                note.SetActive(true);
            }
            
            return note;
        }
        
        /// <summary>
        /// ãƒãƒ¼ãƒ„ã‚’ãƒ—ãƒ¼ãƒ«ã«è¿”å´
        /// </summary>
        public void ReturnNote(GameObject note, NoteType type)
        {
            if (note == null) return;
            
            // ãƒªã‚»ãƒƒãƒˆå‡¦ç†
            note.SetActive(false);
            note.transform.SetParent(poolContainer);
            note.transform.position = Vector3.zero;
            note.transform.rotation = Quaternion.identity;
            note.transform.localScale = Vector3.one;
            
            Queue<GameObject> pool = type == NoteType.Tap ? tapNotePool : holdNotePool;
            
            // ãƒ—ãƒ¼ãƒ«ã‚µã‚¤ã‚ºåˆ¶é™ãƒã‚§ãƒƒã‚¯
            if (pool.Count < maxPoolSize)
            {
                pool.Enqueue(note);
            }
            else
            {
                Destroy(note);
            }
        }
        
        /// <summary>
        /// ãƒ—ãƒ¼ãƒ«ã®çµ±è¨ˆæƒ…å ±ã‚’å–å¾—
        /// </summary>
        public void GetPoolStatistics(out int tapActive, out int tapPooled, 
                                      out int holdActive, out int holdPooled)
        {
            tapPooled = tapNotePool.Count;
            holdPooled = holdNotePool.Count;
            
            // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒãƒ¼ãƒ„ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
            tapActive = 0;
            holdActive = 0;
            
            foreach (Transform child in poolContainer)
            {
                if (child.gameObject.activeInHierarchy)
                {
                    if (child.name.Contains("Tap"))
                        tapActive++;
                    else if (child.name.Contains("Hold"))
                        holdActive++;
                }
            }
        }
        
        /// <summary>
        /// ãƒ—ãƒ¼ãƒ«ã‚’ã‚¯ãƒªã‚¢
        /// </summary>
        public void ClearPool()
        {
            // ã™ã¹ã¦ã®ãƒãƒ¼ãƒ„ã‚’éã‚¢ã‚¯ãƒ†ã‚£ãƒ–åŒ–
            foreach (Transform child in poolContainer)
            {
                child.gameObject.SetActive(false);
            }
            
            // ãƒ—ãƒ¼ãƒ«ã‚’å†æ§‹ç¯‰
            tapNotePool.Clear();
            holdNotePool.Clear();
            
            foreach (Transform child in poolContainer)
            {
                if (child.name.Contains("Tap"))
                    tapNotePool.Enqueue(child.gameObject);
                else if (child.name.Contains("Hold"))
                    holdNotePool.Enqueue(child.gameObject);
            }
            
            Debug.Log("[NotePool] ãƒ—ãƒ¼ãƒ«ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã—ãŸ");
        }
    }
}
```

### ãƒ•ã‚§ãƒ¼ã‚º4: ã‚¨ãƒ‡ã‚£ã‚¿æ‹¡å¼µï¼ˆDay 7-8ï¼‰

#### Day 7: ã‚«ã‚¹ã‚¿ãƒ ã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/_Jirou/Scripts/Editor/ChartDataEditor.cs`

```csharp
#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using Jirou.Core;

namespace Jirou.Editor
{
    /// <summary>
    /// ChartDataã®ã‚«ã‚¹ã‚¿ãƒ ã‚¨ãƒ‡ã‚£ã‚¿
    /// </summary>
    [CustomEditor(typeof(ChartData))]
    public class ChartDataEditor : UnityEditor.Editor
    {
        private ChartData chartData;
        private bool showStatistics = true;
        private bool showValidation = false;
        private List<string> validationErrors = new List<string>();
        
        void OnEnable()
        {
            chartData = (ChartData)target;
        }
        
        public override void OnInspectorGUI()
        {
            // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼ã‚’æç”»
            DrawDefaultInspector();
            
            EditorGUILayout.Space();
            
            // ãƒ„ãƒ¼ãƒ«ãƒœã‚¿ãƒ³
            DrawToolButtons();
            
            EditorGUILayout.Space();
            
            // çµ±è¨ˆæƒ…å ±
            showStatistics = EditorGUILayout.Foldout(showStatistics, "çµ±è¨ˆæƒ…å ±", true);
            if (showStatistics)
            {
                DrawStatistics();
            }
            
            // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³çµæœ
            showValidation = EditorGUILayout.Foldout(showValidation, "ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³", true);
            if (showValidation)
            {
                DrawValidation();
            }
        }
        
        private void DrawToolButtons()
        {
            EditorGUILayout.LabelField("ãƒ„ãƒ¼ãƒ«", EditorStyles.boldLabel);
            
            EditorGUILayout.BeginHorizontal();
            
            if (GUILayout.Button("ãƒãƒ¼ãƒ„ã‚’ã‚½ãƒ¼ãƒˆ"))
            {
                Undo.RecordObject(chartData, "Sort Notes");
                chartData.SortNotesByTime();
                EditorUtility.SetDirty(chartData);
            }
            
            if (GUILayout.Button("è­œé¢ã‚’æ¤œè¨¼"))
            {
                bool isValid = chartData.ValidateChart(out validationErrors);
                showValidation = true;
                
                if (isValid)
                {
                    EditorUtility.DisplayDialog("æ¤œè¨¼çµæœ", "è­œé¢ãƒ‡ãƒ¼ã‚¿ã¯æ­£å¸¸ã§ã™", "OK");
                }
            }
            
            if (GUILayout.Button("ãƒ‡ãƒãƒƒã‚°æƒ…å ±å‡ºåŠ›"))
            {
                chartData.PrintDebugInfo();
            }
            
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            
            if (GUILayout.Button("ã™ã¹ã¦ã®ãƒãƒ¼ãƒ„ã‚’ã‚¯ãƒªã‚¢"))
            {
                if (EditorUtility.DisplayDialog("ç¢ºèª", 
                    "ã™ã¹ã¦ã®ãƒãƒ¼ãƒ„ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ", "å‰Šé™¤", "ã‚­ãƒ£ãƒ³ã‚»ãƒ«"))
                {
                    Undo.RecordObject(chartData, "Clear All Notes");
                    chartData.notes.Clear();
                    EditorUtility.SetDirty(chartData);
                }
            }
            
            if (GUILayout.Button("ãƒ†ã‚¹ãƒˆãƒãƒ¼ãƒ„ã‚’è¿½åŠ "))
            {
                AddTestNotes();
            }
            
            EditorGUILayout.EndHorizontal();
        }
        
        private void DrawStatistics()
        {
            EditorGUI.indentLevel++;
            
            var stats = chartData.GetStatistics();
            
            EditorGUILayout.LabelField("ç·ãƒãƒ¼ãƒ„æ•°:", stats.totalNotes.ToString());
            EditorGUILayout.LabelField("Tapãƒãƒ¼ãƒ„:", stats.tapNotes.ToString());
            EditorGUILayout.LabelField("Holdãƒãƒ¼ãƒ„:", stats.holdNotes.ToString());
            
            EditorGUILayout.LabelField("ãƒ¬ãƒ¼ãƒ³åˆ†å¸ƒ:");
            EditorGUI.indentLevel++;
            for (int i = 0; i < 4; i++)
            {
                float percentage = stats.totalNotes > 0 ? 
                    (float)stats.notesByLane[i] / stats.totalNotes * 100f : 0f;
                    
                EditorGUILayout.LabelField(
                    $"ãƒ¬ãƒ¼ãƒ³ {i} ({NoteData.LaneKeys[i]}):", 
                    $"{stats.notesByLane[i]} ({percentage:F1}%)");
            }
            EditorGUI.indentLevel--;
            
            EditorGUILayout.LabelField("è­œé¢é•·:", 
                $"{stats.chartLengthSeconds:F1}ç§’ ({stats.chartLengthBeats:F1}ãƒ“ãƒ¼ãƒˆ)");
            EditorGUILayout.LabelField("å¹³å‡NPS:", $"{stats.averageNPS:F2}");
            
            if (stats.averageInterval > 0)
            {
                EditorGUILayout.LabelField("å¹³å‡é–“éš”:", $"{stats.averageInterval:F3}ãƒ“ãƒ¼ãƒˆ");
            }
            
            EditorGUI.indentLevel--;
        }
        
        private void DrawValidation()
        {
            EditorGUI.indentLevel++;
            
            if (validationErrors.Count == 0)
            {
                EditorGUILayout.HelpBox("ã‚¨ãƒ©ãƒ¼ã¯ã‚ã‚Šã¾ã›ã‚“", MessageType.Info);
            }
            else
            {
                foreach (var error in validationErrors)
                {
                    EditorGUILayout.HelpBox(error, MessageType.Error);
                }
            }
            
            EditorGUI.indentLevel--;
        }
        
        private void AddTestNotes()
        {
            Undo.RecordObject(chartData, "Add Test Notes");
            
            // 4ãƒ“ãƒ¼ãƒˆã”ã¨ã«å„ãƒ¬ãƒ¼ãƒ³ã«ãƒãƒ¼ãƒ„ã‚’é…ç½®
            for (int beat = 0; beat < 16; beat += 4)
            {
                for (int lane = 0; lane < 4; lane++)
                {
                    var note = new NoteData
                    {
                        noteType = (beat % 8 == 0 && lane % 2 == 0) ? 
                            NoteType.Hold : NoteType.Tap,
                        laneIndex = lane,
                        timeToHit = beat + lane * 0.5f,
                        holdDuration = 2.0f,
                        visualScale = 1.0f,
                        noteColor = Color.white
                    };
                    
                    chartData.notes.Add(note);
                }
            }
            
            chartData.SortNotesByTime();
            EditorUtility.SetDirty(chartData);
            
            Debug.Log($"ãƒ†ã‚¹ãƒˆãƒãƒ¼ãƒ„ã‚’{16}å€‹è¿½åŠ ã—ã¾ã—ãŸ");
        }
    }
}
#endif
```

#### Day 8: è­œé¢ã‚¨ãƒ‡ã‚£ã‚¿ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/_Jirou/Scripts/Editor/ChartEditorWindow.cs`

```csharp
#if UNITY_EDITOR
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;
using Jirou.Core;

namespace Jirou.Editor
{
    /// <summary>
    /// è­œé¢ç·¨é›†ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦
    /// </summary>
    public class ChartEditorWindow : EditorWindow
    {
        [MenuItem("Jirou/Chart Editor")]
        public static void ShowWindow()
        {
            var window = GetWindow<ChartEditorWindow>("Chart Editor");
            window.minSize = new Vector2(400, 600);
        }
        
        private ChartData currentChart;
        private Vector2 scrollPosition;
        private int selectedNoteIndex = -1;
        
        // ãƒ•ã‚£ãƒ«ã‚¿è¨­å®š
        private bool filterEnabled = false;
        private int filterLane = -1;  // -1 = ã™ã¹ã¦
        private NoteType filterType = NoteType.Tap;
        private bool filterTypeEnabled = false;
        
        void OnGUI()
        {
            DrawHeader();
            
            if (currentChart == null)
            {
                EditorGUILayout.HelpBox("ChartDataã‚’é¸æŠã—ã¦ãã ã•ã„", MessageType.Info);
                return;
            }
            
            DrawChartInfo();
            DrawTools();
            DrawFilter();
            DrawNotesList();
        }
        
        private void DrawHeader()
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("è­œé¢ã‚¨ãƒ‡ã‚£ã‚¿", EditorStyles.boldLabel);
            
            currentChart = EditorGUILayout.ObjectField(
                "Chart Data", 
                currentChart, 
                typeof(ChartData), 
                false) as ChartData;
                
            EditorGUILayout.Space();
        }
        
        private void DrawChartInfo()
        {
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            
            EditorGUILayout.LabelField("è­œé¢æƒ…å ±", EditorStyles.boldLabel);
            EditorGUILayout.LabelField($"æ›²å: {currentChart.songName}");
            EditorGUILayout.LabelField($"BPM: {currentChart.bpm}");
            EditorGUILayout.LabelField($"é›£æ˜“åº¦: {currentChart.difficultyName} (Lv.{currentChart.difficulty})");
            EditorGUILayout.LabelField($"ãƒãƒ¼ãƒ„æ•°: {currentChart.notes.Count}");
            
            var stats = currentChart.GetStatistics();
            EditorGUILayout.LabelField($"è­œé¢é•·: {stats.chartLengthSeconds:F1}ç§’");
            
            EditorGUILayout.EndVertical();
        }
        
        private void DrawTools()
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField("ãƒ„ãƒ¼ãƒ«", EditorStyles.boldLabel);
            
            EditorGUILayout.BeginHorizontal();
            
            if (GUILayout.Button("æ–°è¦ãƒãƒ¼ãƒ„è¿½åŠ "))
            {
                AddNewNote();
            }
            
            if (GUILayout.Button("ã‚½ãƒ¼ãƒˆ"))
            {
                currentChart.SortNotesByTime();
                EditorUtility.SetDirty(currentChart);
            }
            
            if (GUILayout.Button("æ¤œè¨¼"))
            {
                List<string> errors;
                if (currentChart.ValidateChart(out errors))
                {
                    EditorUtility.DisplayDialog("æˆåŠŸ", "è­œé¢ã¯æ­£å¸¸ã§ã™", "OK");
                }
                else
                {
                    string errorMsg = string.Join("\n", errors);
                    EditorUtility.DisplayDialog("ã‚¨ãƒ©ãƒ¼", errorMsg, "OK");
                }
            }
            
            EditorGUILayout.EndHorizontal();
            
            EditorGUILayout.BeginHorizontal();
            
            if (GUILayout.Button("JSONã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"))
            {
                ExportToJSON();
            }
            
            if (GUILayout.Button("JSONã‚¤ãƒ³ãƒãƒ¼ãƒˆ"))
            {
                ImportFromJSON();
            }
            
            EditorGUILayout.EndHorizontal();
        }
        
        private void DrawFilter()
        {
            EditorGUILayout.Space();
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            
            filterEnabled = EditorGUILayout.Toggle("ãƒ•ã‚£ãƒ«ã‚¿æœ‰åŠ¹", filterEnabled);
            
            if (filterEnabled)
            {
                EditorGUI.indentLevel++;
                
                filterLane = EditorGUILayout.IntPopup(
                    "ãƒ¬ãƒ¼ãƒ³", 
                    filterLane,
                    new string[] { "ã™ã¹ã¦", "ãƒ¬ãƒ¼ãƒ³0 (D)", "ãƒ¬ãƒ¼ãƒ³1 (F)", "ãƒ¬ãƒ¼ãƒ³2 (J)", "ãƒ¬ãƒ¼ãƒ³3 (K)" },
                    new int[] { -1, 0, 1, 2, 3 });
                    
                filterTypeEnabled = EditorGUILayout.Toggle("ã‚¿ã‚¤ãƒ—ãƒ•ã‚£ãƒ«ã‚¿", filterTypeEnabled);
                if (filterTypeEnabled)
                {
                    filterType = (NoteType)EditorGUILayout.EnumPopup("ãƒãƒ¼ãƒ„ã‚¿ã‚¤ãƒ—", filterType);
                }
                
                EditorGUI.indentLevel--;
            }
            
            EditorGUILayout.EndVertical();
        }
        
        private void DrawNotesList()
        {
            EditorGUILayout.Space();
            EditorGUILayout.LabelField($"ãƒãƒ¼ãƒ„ãƒªã‚¹ãƒˆ ({GetFilteredNotes().Count}ä»¶)", EditorStyles.boldLabel);
            
            scrollPosition = EditorGUILayout.BeginScrollView(scrollPosition, GUILayout.Height(300));
            
            var filteredNotes = GetFilteredNotes();
            
            for (int i = 0; i < filteredNotes.Count; i++)
            {
                var note = filteredNotes[i];
                int originalIndex = currentChart.notes.IndexOf(note);
                
                EditorGUILayout.BeginHorizontal();
                
                // é¸æŠçŠ¶æ…‹ã®è¡¨ç¤º
                bool isSelected = (originalIndex == selectedNoteIndex);
                if (isSelected)
                {
                    GUI.backgroundColor = Color.cyan;
                }
                
                // ãƒãƒ¼ãƒ„æƒ…å ±
                string noteInfo = $"[{originalIndex}] {note.noteType} - " +
                                 $"ãƒ¬ãƒ¼ãƒ³{note.laneIndex} - " +
                                 $"{note.timeToHit:F2}ãƒ“ãƒ¼ãƒˆ";
                                 
                if (note.noteType == NoteType.Hold)
                {
                    noteInfo += $" (é•·ã•: {note.holdDuration:F2})";
                }
                
                if (GUILayout.Button(noteInfo, EditorStyles.miniButton))
                {
                    selectedNoteIndex = originalIndex;
                }
                
                // å‰Šé™¤ãƒœã‚¿ãƒ³
                if (GUILayout.Button("å‰Šé™¤", GUILayout.Width(40)))
                {
                    Undo.RecordObject(currentChart, "Delete Note");
                    currentChart.notes.RemoveAt(originalIndex);
                    EditorUtility.SetDirty(currentChart);
                    selectedNoteIndex = -1;
                }
                
                GUI.backgroundColor = Color.white;
                EditorGUILayout.EndHorizontal();
            }
            
            EditorGUILayout.EndScrollView();
            
            // é¸æŠä¸­ã®ãƒãƒ¼ãƒ„ã®è©³ç´°ç·¨é›†
            if (selectedNoteIndex >= 0 && selectedNoteIndex < currentChart.notes.Count)
            {
                DrawNoteDetails(currentChart.notes[selectedNoteIndex]);
            }
        }
        
        private void DrawNoteDetails(NoteData note)
        {
            EditorGUILayout.Space();
            EditorGUILayout.BeginVertical(EditorStyles.helpBox);
            EditorGUILayout.LabelField("ãƒãƒ¼ãƒ„è©³ç´°", EditorStyles.boldLabel);
            
            EditorGUI.BeginChangeCheck();
            
            note.noteType = (NoteType)EditorGUILayout.EnumPopup("ã‚¿ã‚¤ãƒ—", note.noteType);
            note.laneIndex = EditorGUILayout.IntSlider("ãƒ¬ãƒ¼ãƒ³", note.laneIndex, 0, 3);
            note.timeToHit = EditorGUILayout.FloatField("ã‚¿ã‚¤ãƒŸãƒ³ã‚°ï¼ˆãƒ“ãƒ¼ãƒˆï¼‰", note.timeToHit);
            
            if (note.noteType == NoteType.Hold)
            {
                note.holdDuration = EditorGUILayout.FloatField("é•·ã•ï¼ˆãƒ“ãƒ¼ãƒˆï¼‰", note.holdDuration);
            }
            
            note.visualScale = EditorGUILayout.Slider("ã‚¹ã‚±ãƒ¼ãƒ«", note.visualScale, 0.5f, 2.0f);
            note.noteColor = EditorGUILayout.ColorField("è‰²", note.noteColor);
            
            if (EditorGUI.EndChangeCheck())
            {
                EditorUtility.SetDirty(currentChart);
            }
            
            EditorGUILayout.EndVertical();
        }
        
        private List<NoteData> GetFilteredNotes()
        {
            if (!filterEnabled)
            {
                return currentChart.notes;
            }
            
            var filtered = new List<NoteData>();
            
            foreach (var note in currentChart.notes)
            {
                bool passLaneFilter = (filterLane == -1 || note.laneIndex == filterLane);
                bool passTypeFilter = (!filterTypeEnabled || note.noteType == filterType);
                
                if (passLaneFilter && passTypeFilter)
                {
                    filtered.Add(note);
                }
            }
            
            return filtered;
        }
        
        private void AddNewNote()
        {
            Undo.RecordObject(currentChart, "Add Note");
            
            var newNote = new NoteData
            {
                noteType = NoteType.Tap,
                laneIndex = 0,
                timeToHit = 0f,
                visualScale = 1.0f,
                noteColor = Color.white
            };
            
            currentChart.notes.Add(newNote);
            EditorUtility.SetDirty(currentChart);
            
            selectedNoteIndex = currentChart.notes.Count - 1;
        }
        
        private void ExportToJSON()
        {
            string path = EditorUtility.SaveFilePanel(
                "Export Chart to JSON",
                Application.dataPath,
                currentChart.songName + ".json",
                "json");
                
            if (!string.IsNullOrEmpty(path))
            {
                // JSONå¤‰æ›å‡¦ç†ï¼ˆå®Ÿè£…çœç•¥ï¼‰
                Debug.Log($"ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ: {path}");
                EditorUtility.DisplayDialog("æˆåŠŸ", "JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ", "OK");
            }
        }
        
        private void ImportFromJSON()
        {
            string path = EditorUtility.OpenFilePanel(
                "Import Chart from JSON",
                Application.dataPath,
                "json");
                
            if (!string.IsNullOrEmpty(path))
            {
                // JSONèª­ã¿è¾¼ã¿å‡¦ç†ï¼ˆå®Ÿè£…çœç•¥ï¼‰
                Debug.Log($"ã‚¤ãƒ³ãƒãƒ¼ãƒˆ: {path}");
                EditorUtility.DisplayDialog("æˆåŠŸ", "JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ", "OK");
            }
        }
    }
}
#endif
```

### ãƒ•ã‚§ãƒ¼ã‚º5: ãƒ†ã‚¹ãƒˆå®Ÿè£…ï¼ˆDay 9-10ï¼‰

#### Day 9: ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Tests/EditMode/NoteDataTests.cs`

```csharp
using NUnit.Framework;
using Jirou.Core;
using UnityEngine;

namespace Jirou.Tests
{
    public class NoteDataTests
    {
        [Test]
        public void NoteData_DefaultValues_AreCorrect()
        {
            var note = new NoteData();
            
            Assert.AreEqual(NoteType.Tap, note.noteType);
            Assert.AreEqual(0, note.laneIndex);
            Assert.AreEqual(0f, note.timeToHit);
            Assert.AreEqual(1.0f, note.visualScale);
            Assert.AreEqual(Color.white, note.noteColor);
        }
        
        [Test]
        public void NoteData_LaneXPosition_ReturnsCorrectValue()
        {
            var note = new NoteData();
            
            for (int i = 0; i < 4; i++)
            {
                note.laneIndex = i;
                float expectedX = NoteData.LaneXPositions[i];
                Assert.AreEqual(expectedX, note.GetLaneXPosition());
            }
        }
        
        [Test]
        public void NoteData_GetEndTime_CalculatesCorrectly()
        {
            var tapNote = new NoteData
            {
                noteType = NoteType.Tap,
                timeToHit = 4.0f
            };
            Assert.AreEqual(4.0f, tapNote.GetEndTime());
            
            var holdNote = new NoteData
            {
                noteType = NoteType.Hold,
                timeToHit = 4.0f,
                holdDuration = 2.0f
            };
            Assert.AreEqual(6.0f, holdNote.GetEndTime());
        }
        
        [Test]
        public void NoteData_Validate_DetectsInvalidLaneIndex()
        {
            var note = new NoteData { laneIndex = 5 };
            string error;
            bool isValid = note.Validate(out error);
            
            Assert.IsFalse(isValid);
            Assert.IsTrue(error.Contains("ãƒ¬ãƒ¼ãƒ³ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹"));
        }
        
        [Test]
        public void NoteData_Validate_DetectsNegativeTiming()
        {
            var note = new NoteData { timeToHit = -1.0f };
            string error;
            bool isValid = note.Validate(out error);
            
            Assert.IsFalse(isValid);
            Assert.IsTrue(error.Contains("ã‚¿ã‚¤ãƒŸãƒ³ã‚°"));
        }
        
        [Test]
        public void NoteData_Validate_DetectsInvalidHoldDuration()
        {
            var note = new NoteData
            {
                noteType = NoteType.Hold,
                holdDuration = 0f
            };
            string error;
            bool isValid = note.Validate(out error);
            
            Assert.IsFalse(isValid);
            Assert.IsTrue(error.Contains("Hold"));
        }
    }
    
    public class ChartDataTests
    {
        private ChartData CreateTestChart()
        {
            var chart = ScriptableObject.CreateInstance<ChartData>();
            chart.bpm = 120f;
            chart.songName = "Test Song";
            
            // ãƒ†ã‚¹ãƒˆãƒãƒ¼ãƒ„ã‚’è¿½åŠ 
            chart.notes.Add(new NoteData { laneIndex = 0, timeToHit = 0f });
            chart.notes.Add(new NoteData { laneIndex = 1, timeToHit = 1f });
            chart.notes.Add(new NoteData { laneIndex = 2, timeToHit = 2f });
            chart.notes.Add(new NoteData { laneIndex = 3, timeToHit = 3f });
            
            return chart;
        }
        
        [Test]
        public void ChartData_SortNotesByTime_SortsCorrectly()
        {
            var chart = CreateTestChart();
            
            // é †åºã‚’ä¹±ã™
            var temp = chart.notes[0];
            chart.notes[0] = chart.notes[3];
            chart.notes[3] = temp;
            
            chart.SortNotesByTime();
            
            for (int i = 0; i < chart.notes.Count - 1; i++)
            {
                Assert.LessOrEqual(
                    chart.notes[i].timeToHit,
                    chart.notes[i + 1].timeToHit);
            }
        }
        
        [Test]
        public void ChartData_GetNotesInTimeRange_FiltersCorrectly()
        {
            var chart = CreateTestChart();
            
            var filtered = chart.GetNotesInTimeRange(1f, 2f);
            
            Assert.AreEqual(2, filtered.Count);
            Assert.AreEqual(1f, filtered[0].timeToHit);
            Assert.AreEqual(2f, filtered[1].timeToHit);
        }
        
        [Test]
        public void ChartData_GetNoteCountByLane_CountsCorrectly()
        {
            var chart = CreateTestChart();
            chart.notes.Add(new NoteData { laneIndex = 0, timeToHit = 4f });
            
            var counts = chart.GetNoteCountByLane();
            
            Assert.AreEqual(2, counts[0]);  // ãƒ¬ãƒ¼ãƒ³0ã«2ã¤
            Assert.AreEqual(1, counts[1]);
            Assert.AreEqual(1, counts[2]);
            Assert.AreEqual(1, counts[3]);
        }
        
        [Test]
        public void ChartData_GetChartLengthInBeats_CalculatesCorrectly()
        {
            var chart = CreateTestChart();
            
            // Holdãƒãƒ¼ãƒ„ã‚’è¿½åŠ 
            chart.notes.Add(new NoteData
            {
                noteType = NoteType.Hold,
                timeToHit = 4f,
                holdDuration = 2f
            });
            
            float length = chart.GetChartLengthInBeats();
            Assert.AreEqual(6f, length);  // 4 + 2 = 6
        }
        
        [Test]
        public void ChartData_ValidateChart_DetectsInvalidBPM()
        {
            var chart = CreateTestChart();
            chart.bpm = -1f;
            
            List<string> errors;
            bool isValid = chart.ValidateChart(out errors);
            
            Assert.IsFalse(isValid);
            Assert.IsTrue(errors.Exists(e => e.Contains("BPM")));
        }
    }
    
    public class NoteVisualCalculatorTests
    {
        [Test]
        public void CalculateScaleByDistance_ScalesCorrectly()
        {
            float spawnZ = 20f;
            
            // å¥¥ï¼ˆspawnZï¼‰ã§0.5å€
            float scaleAtSpawn = NoteVisualCalculator.CalculateScaleByDistance(spawnZ, spawnZ);
            Assert.AreEqual(0.5f, scaleAtSpawn, 0.01f);
            
            // æ‰‹å‰ï¼ˆ0ï¼‰ã§1.5å€
            float scaleAtHit = NoteVisualCalculator.CalculateScaleByDistance(0f, spawnZ);
            Assert.AreEqual(1.5f, scaleAtHit, 0.01f);
            
            // ä¸­é–“åœ°ç‚¹
            float scaleAtMiddle = NoteVisualCalculator.CalculateScaleByDistance(10f, spawnZ);
            Assert.AreEqual(1.0f, scaleAtMiddle, 0.01f);
        }
        
        [Test]
        public void CalculateAlphaByDistance_FadesCorrectly()
        {
            float spawnZ = 20f;
            
            // 80%åœ°ç‚¹ã‚ˆã‚Šæ‰‹å‰ã¯å®Œå…¨ä¸é€æ˜
            float alphaAt70Percent = NoteVisualCalculator.CalculateAlphaByDistance(14f, spawnZ);
            Assert.AreEqual(1.0f, alphaAt70Percent);
            
            // ã‚¹ãƒãƒ¼ãƒ³åœ°ç‚¹ã§å®Œå…¨é€æ˜
            float alphaAtSpawn = NoteVisualCalculator.CalculateAlphaByDistance(spawnZ, spawnZ);
            Assert.AreEqual(0f, alphaAtSpawn, 0.01f);
        }
        
        [Test]
        public void NotePosition3D_ConstructsCorrectly()
        {
            var pos = new NotePosition3D(1, 10f, 0.5f);
            
            Assert.AreEqual(-1f, pos.x);  // ãƒ¬ãƒ¼ãƒ³1ã®Xåº§æ¨™
            Assert.AreEqual(0.5f, pos.y);
            Assert.AreEqual(10f, pos.z);
            
            Vector3 vec = pos.ToVector3();
            Assert.AreEqual(new Vector3(-1f, 0.5f, 10f), vec);
        }
    }
}
```

#### Day 10: çµ±åˆãƒ†ã‚¹ãƒˆã¨ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«**: `Assets/Tests/PlayMode/NoteDataIntegrationTests.cs`

```csharp
using System.Collections;
using NUnit.Framework;
using UnityEngine;
using UnityEngine.TestTools;
using Jirou.Core;

namespace Jirou.Tests
{
    public class NoteDataIntegrationTests
    {
        [UnityTest]
        public IEnumerator ChartData_LoadLargeChart_PerformanceTest()
        {
            // å¤§é‡ãƒãƒ¼ãƒ„ã®è­œé¢ã‚’ä½œæˆ
            var chart = ScriptableObject.CreateInstance<ChartData>();
            chart.bpm = 180f;
            
            // 1000å€‹ã®ãƒãƒ¼ãƒ„ã‚’è¿½åŠ 
            for (int i = 0; i < 1000; i++)
            {
                chart.notes.Add(new NoteData
                {
                    noteType = i % 5 == 0 ? NoteType.Hold : NoteType.Tap,
                    laneIndex = i % 4,
                    timeToHit = i * 0.25f,
                    holdDuration = 1.0f
                });
            }
            
            // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æ¸¬å®š
            float startTime = Time.realtimeSinceStartup;
            
            // å„ç¨®å‡¦ç†ã®ãƒ†ã‚¹ãƒˆ
            chart.SortNotesByTime();
            var stats = chart.GetStatistics();
            var filtered = chart.GetNotesInTimeRange(100f, 200f);
            
            float elapsedTime = Time.realtimeSinceStartup - startTime;
            
            // 1ç§’ä»¥å†…ã«å®Œäº†ã™ã‚‹ã“ã¨
            Assert.Less(elapsedTime, 1.0f, 
                $"å‡¦ç†æ™‚é–“ãŒé•·ã™ãã¾ã™: {elapsedTime}ç§’");
            
            yield return null;
        }
        
        [UnityTest]
        public IEnumerator NotePool_StressTest()
        {
            // ãƒãƒ¼ãƒ„ãƒ—ãƒ¼ãƒ«ã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
            GameObject poolObject = new GameObject("TestNotePool");
            var poolManager = poolObject.AddComponent<NotePoolManager>();
            
            yield return null;  // åˆæœŸåŒ–å¾…ã¡
            
            // å¤§é‡ã®ãƒãƒ¼ãƒ„ã‚’å–å¾—ãƒ»è¿”å´
            GameObject[] notes = new GameObject[100];
            
            // å–å¾—ãƒ†ã‚¹ãƒˆ
            for (int i = 0; i < notes.Length; i++)
            {
                notes[i] = poolManager.GetNote(NoteType.Tap);
                Assert.IsNotNull(notes[i]);
            }
            
            // è¿”å´ãƒ†ã‚¹ãƒˆ
            for (int i = 0; i < notes.Length; i++)
            {
                poolManager.ReturnNote(notes[i], NoteType.Tap);
            }
            
            // çµ±è¨ˆæƒ…å ±ã®ç¢ºèª
            int tapActive, tapPooled, holdActive, holdPooled;
            poolManager.GetPoolStatistics(
                out tapActive, out tapPooled,
                out holdActive, out holdPooled);
                
            Assert.AreEqual(0, tapActive, "ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªãƒãƒ¼ãƒ„ãŒæ®‹ã£ã¦ã„ã¾ã™");
            Assert.Greater(tapPooled, 0, "ãƒ—ãƒ¼ãƒ«ãŒç©ºã§ã™");
            
            Object.Destroy(poolObject);
            
            yield return null;
        }
        
        [UnityTest]
        public IEnumerator NoteVisual_3DPositionUpdate()
        {
            // Conductorã®ãƒ¢ãƒƒã‚¯
            GameObject conductorObject = new GameObject("TestConductor");
            var conductor = conductorObject.AddComponent<Conductor>();
            conductor.songBpm = 120f;
            conductor.noteSpeed = 10f;
            conductor.spawnZ = 20f;
            
            yield return null;
            
            // ãƒãƒ¼ãƒ„ãƒ‡ãƒ¼ã‚¿
            var noteData = new NoteData
            {
                laneIndex = 1,
                timeToHit = 2.0f
            };
            
            // ä½ç½®è¨ˆç®—ãƒ†ã‚¹ãƒˆ
            conductor.StartSong();
            
            yield return new WaitForSeconds(0.5f);
            
            Vector3 notePos = NoteVisualCalculator.CalculateNoteWorldPosition(
                noteData, conductor.songPositionInBeats, conductor);
                
            // Xåº§æ¨™ã®ç¢ºèªï¼ˆãƒ¬ãƒ¼ãƒ³1ï¼‰
            Assert.AreEqual(-1f, notePos.x, 0.01f);
            
            // Zåº§æ¨™ãŒç§»å‹•ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
            Assert.Less(notePos.z, conductor.spawnZ);
            
            Object.Destroy(conductorObject);
        }
    }
}
```

## å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### å¿…é ˆå®Ÿè£…é …ç›®

- [x] **NoteData.cs** - åŸºæœ¬ãƒ‡ãƒ¼ã‚¿æ§‹é€  âœ… å®Ÿè£…å®Œäº†ï¼ˆDay 1 å®Œäº†ï¼‰
  - ãƒãƒ¼ãƒ„ã‚¿ã‚¤ãƒ—ï¼ˆTap/Holdï¼‰ã®å®šç¾©
  - ãƒ¬ãƒ¼ãƒ³ä½ç½®ãƒ»ã‚¿ã‚¤ãƒŸãƒ³ã‚°ç®¡ç†
  - ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½å®Ÿè£…æ¸ˆã¿
  
- [x] **ChartData.cs** - ScriptableObjectå®Ÿè£… âœ… å®Ÿè£…å®Œäº†ï¼ˆDay 2-4 å®Œäº†ï¼‰
  - æ¥½æ›²æƒ…å ±ãƒ»è­œé¢ãƒ‡ãƒ¼ã‚¿ç®¡ç†
  - ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰å®Ÿè£…æ¸ˆã¿
  - çµ±è¨ˆæƒ…å ±ãƒ»ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³æ©Ÿèƒ½å®Œå‚™
  
- [x] **NotePositionHelper.cs** - 3Dä½ç½®è¨ˆç®— âœ… å®Ÿè£…å®Œäº†ï¼ˆDay 5 å®Œäº†ï¼‰
  - NotePosition3Dæ§‹é€ ä½“å®Ÿè£…æ¸ˆã¿
  - NoteVisualCalculatoré™çš„ã‚¯ãƒ©ã‚¹å®Ÿè£…æ¸ˆã¿
  - Conductoré€£æºæ©Ÿèƒ½å®Œå‚™
  
- [x] **NotePoolManager.cs** - ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ« âœ… å®Ÿè£…å®Œäº†ï¼ˆDay 6 å®Œäº†ï¼‰
  - ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³å®Ÿè£…æ¸ˆã¿
  - Tap/Holdãƒãƒ¼ãƒ„åˆ¥ãƒ—ãƒ¼ãƒ«ç®¡ç†
  - ãƒ¡ãƒ¢ãƒªæœ€é©åŒ–æ©Ÿèƒ½å®Œå‚™
  
- [x] **ChartDataEditor.cs** - ã‚«ã‚¹ã‚¿ãƒ ã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼ âœ… å®Ÿè£…å®Œäº†ï¼ˆDay 7 å®Œäº†ï¼‰
- [x] **ChartEditorWindow.cs** - è­œé¢ã‚¨ãƒ‡ã‚£ã‚¿ âœ… å®Ÿè£…å®Œäº†ï¼ˆDay 8 å®Œäº†ï¼‰

### ãƒ†ã‚¹ãƒˆå®Ÿè£…çŠ¶æ³

- [x] **NoteDataTests.cs** - ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆ âœ… å®Ÿè£…å®Œäº†
- [x] **ChartDataTests.cs** - ChartDataãƒ†ã‚¹ãƒˆ âœ… å®Ÿè£…å®Œäº†
- [x] **NotePositionHelperTests.cs** - ä½ç½®è¨ˆç®—ãƒ†ã‚¹ãƒˆ âœ… å®Ÿè£…å®Œäº†
- [x] **NoteDataIntegrationTests.cs** - çµ±åˆãƒ†ã‚¹ãƒˆ âœ… å®Ÿè£…å®Œäº†
- [x] **NotePoolManagerTests.cs** - ãƒ—ãƒ¼ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ãƒ†ã‚¹ãƒˆ âœ… å®Ÿè£…å®Œäº†
- [x] **åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ** - EditMode/PlayModeãƒ†ã‚¹ãƒˆå……å®Ÿ âœ… å®Ÿè£…å®Œäº†

### ã‚ªãƒ—ã‚·ãƒ§ãƒ³å®Ÿè£…é …ç›®

- [x] JSON ã‚¤ãƒ³ãƒãƒ¼ãƒˆ/ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆæ©Ÿèƒ½ âœ… å®Ÿè£…å®Œäº†ï¼ˆChartEditorWindowå†…ã«å®Ÿè£…ï¼‰
- [ ] CSV ã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½
- [ ] è­œé¢è‡ªå‹•ç”Ÿæˆãƒ„ãƒ¼ãƒ«
- [ ] ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¨ãƒ‡ã‚£ã‚¿

## ãƒªã‚¹ã‚¯ç®¡ç†

### æŠ€è¡“çš„ãƒªã‚¹ã‚¯

| ãƒªã‚¹ã‚¯ | å½±éŸ¿åº¦ | å¯¾ç­– |
|-------|--------|------|
| å¤§é‡ãƒãƒ¼ãƒ„ã§ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ä½ä¸‹ | é«˜ | ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«å®Ÿè£…ã€LODã‚·ã‚¹ãƒ†ãƒ  |
| ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ã®å¢—å¤§ | ä¸­ | å‹•çš„ãƒ­ãƒ¼ãƒ‰/ã‚¢ãƒ³ãƒ­ãƒ¼ãƒ‰æ©Ÿæ§‹ |
| ãƒ‡ãƒ¼ã‚¿ç ´æ | ä¸­ | ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³å¼·åŒ–ã€ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æ©Ÿèƒ½ |

### ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ãƒªã‚¹ã‚¯

| ãƒªã‚¹ã‚¯ | å½±éŸ¿åº¦ | å¯¾ç­– |
|-------|--------|------|
| ã‚¨ãƒ‡ã‚£ã‚¿ãƒ„ãƒ¼ãƒ«ã®å®Ÿè£…é…å»¶ | ä½ | åŸºæœ¬æ©Ÿèƒ½ã‚’å„ªå…ˆã€æ®µéšçš„å®Ÿè£… |
| ãƒ†ã‚¹ãƒˆä¸è¶³ | ä¸­ | è‡ªå‹•ãƒ†ã‚¹ãƒˆã®æ—©æœŸå®Ÿè£… |

## ãƒ‡ãƒãƒƒã‚°ã¨ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºç­–

1. **ãƒãƒ¼ãƒ„ãŒè¡¨ç¤ºã•ã‚Œãªã„**
   - ãƒ—ãƒ¬ãƒãƒ–å‚ç…§ã‚’ç¢ºèª
   - ãƒ¬ã‚¤ãƒ¤ãƒ¼è¨­å®šã‚’ç¢ºèª
   - ã‚«ãƒ¡ãƒ©ã®Culling Maskã‚’ç¢ºèª

2. **ã‚¿ã‚¤ãƒŸãƒ³ã‚°ãŒãšã‚Œã‚‹**
   - AudioSettings.dspTimeã®ä½¿ç”¨ã‚’ç¢ºèª
   - firstBeatOffsetã®èª¿æ•´
   - ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆä¾å­˜ã‚³ãƒ¼ãƒ‰ã®æ’é™¤

3. **ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯**
   - ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«ã®è¿”å´å‡¦ç†ã‚’ç¢ºèª
   - ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã®è§£é™¤ã‚’ç¢ºèª
   - ä¸è¦ãªå‚ç…§ã®å‰Šé™¤

### ãƒ‡ãƒãƒƒã‚°ãƒ„ãƒ¼ãƒ«

```csharp
// ãƒ‡ãƒãƒƒã‚°ç”¨ã®Gizmoæç”»
void OnDrawGizmos()
{
    if (Application.isPlaying && currentChart != null)
    {
        foreach (var note in currentChart.notes)
        {
            Vector3 pos = new Vector3(
                NoteData.LaneXPositions[note.laneIndex],
                0.5f,
                Conductor.Instance.GetNoteZPosition(note.timeToHit));
                
            Gizmos.color = note.noteType == NoteType.Hold ? 
                Color.yellow : Color.red;
            Gizmos.DrawWireCube(pos, Vector3.one * 0.5f);
        }
    }
}
```

## æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ï¼ˆæ¨å¥¨å®Ÿè£…é †åºï¼‰

### çŸ­æœŸç›®æ¨™ï¼ˆ1-2æ—¥ï¼‰ âœ… **å®Œäº†æ¸ˆã¿**
1. ~~**NotePositionHelper.cså®Ÿè£…**~~ âœ… å®Œäº†
   - ~~3Dåº§æ¨™è¨ˆç®—ã®åŸºæœ¬å®Ÿè£…~~ âœ… å®Œäº†
   - ~~Conductorã¨ã®é€£æºæ©Ÿèƒ½~~ âœ… å®Œäº†
   - ~~è¦–è¦šåŠ¹æœè¨ˆç®—ãƒ¡ã‚½ãƒƒãƒ‰~~ âœ… å®Œäº†

2. ~~**NotePoolManager.cså®Ÿè£…**~~ âœ… å®Œäº†
   - ~~ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ—ãƒ¼ãƒ«ã®åŸºæœ¬æ§‹é€ ~~ âœ… å®Œäº†
   - ~~ãƒãƒ¼ãƒ„ã®å–å¾—ãƒ»è¿”å´ã‚·ã‚¹ãƒ†ãƒ ~~ âœ… å®Œäº†
   - ~~ãƒ¡ãƒ¢ãƒªç®¡ç†ã®æœ€é©åŒ–~~ âœ… å®Œäº†

### ä¸­æœŸç›®æ¨™ï¼ˆ3-5æ—¥ï¼‰ âœ… **å®Œäº†**
3. ~~**ã‚¨ãƒ‡ã‚£ã‚¿æ‹¡å¼µã®å®Ÿè£…**~~ âœ… å®Œäº†
   - ~~ChartDataEditor.csã«ã‚ˆã‚‹ã‚¤ãƒ³ã‚¹ãƒšã‚¯ã‚¿ãƒ¼æ”¹å–„~~ âœ… å®Œäº†
   - ~~ChartEditorWindow.csã«ã‚ˆã‚‹è­œé¢ç·¨é›†æ©Ÿèƒ½~~ âœ… å®Œäº†

4. ~~**çµ±åˆãƒ†ã‚¹ãƒˆã®å……å®Ÿ**~~ âœ… å®Œäº†
   - ~~PlayModeã§ã®å®Ÿéš›ã®ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ãƒ†ã‚¹ãƒˆ~~ âœ… å®Œäº†
   - ~~ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã®è¿½åŠ ~~ âœ… å®Œäº†

### é•·æœŸç›®æ¨™ï¼ˆ1é€±é–“ä»¥é™ï¼‰
5. **è¿½åŠ æ©Ÿèƒ½ã®å®Ÿè£…**
   - ~~JSONã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒ»ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ~~ âœ… å®Œäº†
   - CSVã‚¤ãƒ³ãƒãƒ¼ãƒˆæ©Ÿèƒ½ï¼ˆæœªå®Ÿè£…ï¼‰
   - è­œé¢è‡ªå‹•ç”Ÿæˆãƒ„ãƒ¼ãƒ«ï¼ˆæœªå®Ÿè£…ï¼‰
   - ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ã‚¨ãƒ‡ã‚£ã‚¿ï¼ˆæœªå®Ÿè£…ï¼‰

## ã¾ã¨ã‚

**ğŸ‰ğŸ‰ğŸ‰ ãƒãƒ¼ãƒ„ãƒ‡ãƒ¼ã‚¿ã‚·ã‚¹ãƒ†ãƒ ã¯100%å®Œå…¨å®Ÿè£…ã•ã‚Œã¾ã—ãŸï¼ï¼ï¼ ğŸ‰ğŸ‰ğŸ‰**

æœ¬å®Ÿè£…è¨ˆç”»æ›¸ã«åŸºã¥ãæ®µéšçš„ãªå®Ÿè£…ã«ã‚ˆã‚Šã€å …ç‰¢ã§æ‹¡å¼µæ€§ã®é«˜ã„ãƒãƒ¼ãƒ„ãƒ‡ãƒ¼ã‚¿ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹ç¯‰ãŒ **å®Œå…¨ã«å®Œäº†** ã—ã¾ã—ãŸã€‚

### ğŸ“ˆ **é”æˆæ¸ˆã¿ã®ä¸»è¦æˆæœ**
- âœ… **å®Œå…¨ãªãƒ‡ãƒ¼ã‚¿æ§‹é€ **: NoteDataã€ChartDataã®å®Ÿè£…å®Œäº†
- âœ… **3Dåº§æ¨™è¨ˆç®—ã‚·ã‚¹ãƒ†ãƒ **: NotePositionHelperã«ã‚ˆã‚‹å¥¥è¡Œãè¡¨ç¾å¯¾å¿œ
- âœ… **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–**: NotePoolManagerã«ã‚ˆã‚‹ãƒ¡ãƒ¢ãƒªåŠ¹ç‡åŒ–
- âœ… **åŒ…æ‹¬çš„ãƒ†ã‚¹ãƒˆã‚«ãƒãƒ¬ãƒƒã‚¸**: EditMode/PlayModeãƒ†ã‚¹ãƒˆå……å®Ÿ
- âœ… **ã‚¨ãƒ‡ã‚£ã‚¿æ‹¡å¼µæ©Ÿèƒ½**: ChartDataEditorã€ChartEditorWindowã®å®Œå…¨å®Ÿè£…
- âœ… **JSONã‚¤ãƒ³ãƒãƒ¼ãƒˆ/ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ**: è­œé¢ãƒ‡ãƒ¼ã‚¿ã®å¤–éƒ¨ä¿å­˜ãƒ»èª­ã¿è¾¼ã¿æ©Ÿèƒ½
- âœ… **è¨­è¨ˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¨ã®å®Œå…¨æ•´åˆæ€§**: ä»•æ§˜é€šã‚Šã®å®Ÿè£…

### ğŸš€ **å®Ÿè£…å®Œäº†ã«ã‚ˆã‚Šå¯èƒ½ã«ãªã£ãŸã“ã¨**
- è­œé¢ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆãƒ»ç·¨é›†ãƒ»ç®¡ç†ãŒå®Œå…¨ã«Unityã‚¨ãƒ‡ã‚£ã‚¿å†…ã§å¯èƒ½
- JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ã‚ˆã‚‹è­œé¢ãƒ‡ãƒ¼ã‚¿ã®å…±æœ‰ãƒ»ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
- åŠ¹ç‡çš„ãªãƒ¡ãƒ¢ãƒªç®¡ç†ã«ã‚ˆã‚‹ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æœ€é©åŒ–
- åŒ…æ‹¬çš„ãªãƒ†ã‚¹ãƒˆã«ã‚ˆã‚‹é«˜ã„ä¿¡é ¼æ€§

**å¥¥è¡Œãå‹ãƒªã‚ºãƒ ã‚²ãƒ¼ãƒ ã®é–‹ç™ºã«å¿…è¦ãªãƒãƒ¼ãƒ„ãƒ‡ãƒ¼ã‚¿ã‚·ã‚¹ãƒ†ãƒ ã®ã™ã¹ã¦ã®æ©Ÿèƒ½ãŒå®Ÿè£…ã•ã‚Œã€ãƒ—ãƒ­ãƒ€ã‚¯ã‚·ãƒ§ãƒ³ãƒ¬ãƒ‡ã‚£ãªçŠ¶æ…‹ã«ãªã‚Šã¾ã—ãŸã€‚**