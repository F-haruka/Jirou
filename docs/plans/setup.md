# リズムゲームプロジェクト - 開発環境セットアップとベストプラクティス

## はじめに

### 目的と理念

本ドキュメントは、新規リズムゲームプロジェクトの技術的基盤を構築するための設計図として機能します。ここでは、安定性、拡張性、そして共同作業の効率性を最優先事項とし、開発環境を綿密に構築します。

本アプローチの目的は、単にプロジェクトを起動可能にすることではなく、開発初日からプロフェッショナルなパイプラインを確立することにあります。

### 厳格なセットアップの背景にある「なぜ」

不適切に構成されたプロジェクトは、長期的には多大なコストを発生させます：
- バージョン管理の悪夢
- 解決困難なマージコンフリクト
- 新規チームメンバーのオンボーディングの遅延
- 着実に蓄積される技術的負債

これとは対照的に、強固な基盤を構築することで、開発速度の向上、チーム内の摩擦の軽減、そしてより快適な開発プロセスといった恩恵がもたらされます。本ガイドは、将来の障害を未然に防ぎ、プロジェクトの成功確率を最大化するための投資です。

### 最新のワークフロー：Claude Codeの統合

本プロジェクトでは、「**Vibe coding**」として知られるAI支援開発手法を導入します。これは、開発者を置き換えるものではなく、強力な「ペアプログラマー」あるいは「副操縦士」としてAIを活用するアプローチです。

このツールを最大限に活用するためには、プロジェクトの構造とドキュメンテーションを整備し、AIに対して明確かつ曖昧さのないコンテキストを提供することが不可欠です。この理念に基づき、本ガイドでは独自の`_Docs`ディレクトリを導入し、ドキュメンテーションを開発プロセスの中核に据えるアプローチを提案します。

---

## パート1：基盤となるツールチェーンのセットアップ

このセクションでは、Windowsマシン上に、開発環境全体を支える柱となる、不可欠なソフトウェアを一度だけインストールする手順について詳述します。

### 1.1. Unity IDの確立

**アクション:** Unity IDを作成します。これは、Unity Hub、Unity Editor、Asset Storeなど、Unityエコシステム全体にアクセスするために必須のものです。

**プロセス:**
1. [id.unity.com](https://id.unity.com)のUnity ID作成ページにアクセスします
2. 要求される情報を入力します：
   - 有効なメールアドレス
   - 強固なパスワード
   - 一意のユーザー名（フォーラム等で公開されます）
   - フルネーム
3. 利用規約とプライバシーポリシーに同意します
4. 受信したメールに記載されているリンクをクリックして、メールアドレスの認証プロセスを完了させます（このステップはアカウントを有効化するために極めて重要です）

### 1.2. Unity Hubのインストール：開発の司令塔

**アクション:** Unity Hubをダウンロードし、インストールします。

**理由:** Unity Hubは、複数のUnity Editorのインストール、プロジェクト、ライセンスを管理するための公式かつ必須のツールです。プロの開発現場では、異なるプロジェクトで異なるバージョンを使用する状況が頻繁に発生しますが、Unity Hubはそのようなバージョン管理の複雑さを抽象化し、効率的な管理を可能にします。

**プロセス:**
1. Unityの公式ダウンロードページからインストーラーをダウンロードします
2. `UnityHubSetup.exe`インストーラーを実行し、ライセンス契約に同意します
3. インストール先を選択します（デフォルトの`C:\Program Files\Unity Hub`で問題ありません）
4. Unity Hubを起動し、先ほど作成したUnity IDでサインインします
5. 歯車アイコン → 「ライセンスを管理」 → 「新しいライセンスを取得」の順に進み、無料の「Personal」ライセンスを有効化します

### 1.3. Gitのインストールと設定：信頼できる唯一の情報源

**アクション:** Git for Windowsをインストールし、Git LFSを初期化します。

**理由:** バージョン管理は、共同開発において最も重要なツールであり、Gitはその業界標準です。Unityプロジェクトにはテクスチャや音声ファイルといった、Gitが単体では効率的に扱えない大きなバイナリファイルが必ず含まれるため、Git Large File Storage (LFS)も最初から導入します。この初期設定が、将来発生しうるリポジトリに関する深刻な問題を未然に防ぎます。

**プロセス:**
1. 公式サイトからGit for Windowsのインストーラーをダウンロードします
2. インストール中は、ほとんどのステップでデフォルト設定を受け入れます（SourceTreeやForkのようなGUIクライアントの使用を強く推奨しますが、コマンドラインの基本を理解することは不可欠です）
3. インストール後、新しいコマンドプロンプトまたはGit Bashターミナルを開きます
4. `git lfs install`コマンドを実行します（これはマシン上で一度だけ行う設定で、Gitが必要に応じてLFSフィルターを使用するように構成します）

> **重要な注意点：Git LFSを最初から導入する理由**
> 
> 多くの開発プロセスでは、Git LFSはリポジトリがバイナリファイルで肥大化した後に追加されるものとして紹介されがちです。しかし、LFSはファイル「タイプ」を追跡することで機能します。
> 
> Unityプロジェクトは、初期段階からデフォルトのスプライトやUI要素、最終的には音声ファイルといったバイナリ資産を必ず含みます。LFSの導入を後回しにすると、これらの初期アセットが直接Gitの履歴にコミットされてしまいます。
> 
> Gitはファイルのバージョンごとに完全なコピーを保存するため、1MBのPNGファイルを10回変更すると、最終的なファイルサイズが1MBであっても、リポジトリの履歴は10MBも肥大化します。この肥大化は永続的であり、チームメンバー全員のクローンやフェッチ操作を恒久的に遅くします。
> 
> 既存のファイルをLFSに移行する作業は複雑で、リポジトリの履歴を破壊するリスクも伴います。したがって、最も効率的で安全なアプローチは、LFSをアドオンではなく、初期Gitセットアップの不可欠な一部として扱うことです。

---

## パート2：Unityプロジェクトの初期化

基盤となるツールが整ったので、次にUnityプロジェクト自体を作成します。ここでは、Editorのバージョンとプロジェクトテンプレートについて、意図的かつ情報に基づいた決定を下します。

### 2.1. 最適なUnity Editorバージョンの選定

**アクション:** Unity Hub経由で、最新の長期サポート（LTS）版のUnity Editorをインストールします。

**理由:** Unityは2つのリリース追跡を提供しています：
- **テックストリーム** - 最新機能を含むが、不安定な可能性がある
- **LTS** - 新機能は少ないが、安定しており2年間のバグ修正サポートが保証されている

製品化を目指すいかなるプロジェクトにおいても、安定性は最優先事項です。LTSは、安定したプラットフォームを保証し、エンジン起因のバグによって開発が頓挫するリスクを最小限に抑えるため、プロフェッショナルの標準となっています。

**プロセス:**
1. Unity Hubで、「インストール」タブに移動します
2. 「エディターをインストール」をクリックします
3. 「(LTS)」とマークされた最新バージョンを選択します（例: Unity 2022.3.xやUnity 6.0 LTS）
4. 「モジュールを加える」画面で、「Microsoft Visual Studio Community [Version]」にチェックが入っていることを確認します（C#スクリプティングに使用するIDE）
5. このPC専用プロジェクトでは、現時点で他のプラットフォームモジュール（AndroidやiOSなど）は不要です（要件が変更された場合は後から追加できます）
### 2.2. テンプレートからのプロジェクト作成

**アクション:** 「2D (URP)」テンプレートを使用して新規プロジェクトを作成します。

**理由:** このゲームは基本的に2Dですが、Universal Render Pipeline (URP) テンプレートを使用することで、高度な2Dライティング、Shader Graphによるカスタムシェーダー、ポストプロセッシングエフェクトといった機能を標準で利用できます。

視覚的なフィードバック、パーティクルエフェクト、そして「ジュース（演出）」が重要なリズムゲームにとって、これらの機能は非常に価値があり、従来のビルトインレンダーパイプラインで開始したプロジェクトに後から組み込むのは困難です。URPはUnityの現代的でスケーラブルなレンダリングソリューションです。

**プロセス:**
1. Unity Hubで、「プロジェクト」タブに移動します
2. 「新しいプロジェクト」をクリックします
3. 先ほどインストールしたLTS版のEditorを選択します
4. テンプレートリストから「2D (URP)」を選択します
5. プロジェクトに明確で分かりやすい名前を付けます（例: `Rhythm-Game-Project`）
   - **重要:** プロジェクト名やパスにスペースを使用しないこと
   - パスカルケースまたはケバブケースを使用してください
6. プロジェクトフォルダを保存する場所をハードドライブ上で選択します
7. 「プロジェクトを作成」をクリックします
### 2.3. 初期プロジェクト設定の構成

**アクション:** バージョン管理との互換性のために、主要なプロジェクト設定を構成します。

**理由:** Unityのデフォルト設定は、Gitを使用するチーム環境にとって必ずしも最適ではありません。アセットファイルが、Gitが効果的に追跡しマージできるテキストベースのフォーマットで保存されるように設定する必要があります。

**プロセス:**
1. プロジェクトが開いたら、`Edit > Project Settings`に移動します
2. **Editorタブ**で、`Asset Serialization Mode`を`Force Text`に変更します
   - これはGitとの互換性において最も重要な設定です
   - シーン（.unity）、プレハブ（.prefab）、その他のアセットファイルが人間が読めるYAMLテキストとして保存されます
   - Gitが変更点を一行ずつ表示できるようになり、マージが容易になります
3. 同じくProject Settings内で、**Version Control**に移動し、`Mode`を`Visible Meta Files`に設定します
   - すべてのアセット（例: Player.png）に対応する.metaファイル（例: Player.png.meta）が生成されます
   - このメタファイルにはアセットのインポート設定や一意のIDが含まれており、バージョン管理に必ずコミットする必要があります
### 表1: 推奨されるUnity Editorのバージョン

| 特徴 | 長期サポート (LTS) | テックストリーム |
|------|-------------------|------------------|
| **主な目的** | 安定性と信頼性 | 最新機能とイノベーション |
| **サポートサイクル** | 2年間のサポートと定期的なバグ修正 | 次のテックストリーム版がリリースされるまでのサポート |
| **理想的な用途** | 製品版プロジェクト、ライブゲーム、長期開発 | プロトタイピング、研究開発、新エンジンの機能調査 |
| **リスクプロファイル** | 低：十分にテストされ、パッチが適用されている | 高：開発を妨げるエンジンレベルのバグを含む可能性がある |
| **本プロジェクトの選択** | ✅ 最新のLTSバージョンを使用 | ❌ 本プロジェクトでは使用しない |

---

## パート3：プロフェッショナルなバージョン管理の統合

このセクションは、プロジェクトの整合性とチームの共同作業を確保するために最も重要です。Unityプロジェクト特有の要求に対応できるよう、Gitリポジトリを綿密に設定します。
### 3.1. ローカルGitリポジトリの初期化

**アクション:** UnityプロジェクトのルートディレクトリにGitリポジトリを初期化します。

**プロセス:**
1. Unity Editorを閉じます（ファイルのロック問題を避けるために重要）
2. プロジェクトのルートフォルダ（Assets、Library、ProjectSettingsディレクトリが含まれるフォルダ）で、コマンドプロンプトまたはGit Bashターミナルを開きます
3. `git init`コマンドを実行します
   - これにより、隠しフォルダ`.git`が作成され、プロジェクトディレクトリがローカルのGitリポジトリになります
### 3.2. 不可欠な.gitignoreファイルの作成

**アクション:** Gitに無視させるファイルやフォルダを指定するための`.gitignore`ファイルを作成します。

**理由:** Unityプロジェクトは、バージョン管理に決してコミットすべきではない、多数の巨大な、マシン固有の、あるいは一時的なファイル（例: Library、Temp、Logsフォルダ）を生成します。これらをコミットすると、リポジトリの肥大化と、無関係なマージコンフリクトが絶えず発生する原因となります。業界のベストプラクティスであるGitHubが提供する標準テンプレートを使用します。

**プロセス:**
1. プロジェクトのルートに、`.gitignore`という名前の新しいテキストファイルを作成します（先頭のドットと拡張子がない点に注意）
2. このファイルに、公式のGitHub Unity gitignoreテンプレートの内容を記述します

以下に主要なエントリを示します：

```gitignore
# Unity-generated folders
/[Ll]ibrary/
/[Tt]emp/
/[Oo]bj/
/[Bb]uild/
/[Bb]uilds/
/[Ll]ogs/
/[Uu]ser[Ss]ettings/

# Visual Studio files
.vs/
*.csproj
*.sln
```

### 3.3. ゲームアセットのためのGit LFSの設定

**アクション:** Git LFSで扱うべきファイルタイプを指定するための`.gitattributes`ファイルを作成します。

**理由:** パート1で確立した通り、LFSにどのバイナリファイルを追跡させるかを指示する必要があります。これは`.gitattributes`ファイル内のパターンによって行われます。これにより、大きなアセットはメインリポジトリ内では小さなテキストポインタに置き換えられ、実際のファイルデータはLFSストレージに別途保存されることが保証されます。

**プロセス:**
1. プロジェクトのルートに、`.gitattributes`という名前の新しいテキストファイルを作成します
2. このファイルに、一般的なゲームアセットタイプのためのルールを記述します

このリズムゲームプロジェクトでは、初期段階では音声ファイルと画像ファイルが最も重要な対象となります：

```gitattributes# Image files
*.png filter=lfs diff=lfs merge=lfs -text
*.jpg filter=lfs diff=lfs merge=lfs -text
*.psd filter=lfs diff=lfs merge=lfs -text

# Audio files
*.mp3 filter=lfs diff=lfs merge=lfs -text
*.wav filter=lfs diff=lfs merge=lfs -text
*.ogg filter=lfs diff=lfs merge=lfs -text

# 3D Models (for future use)
*.fbx filter=lfs diff=lfs merge=lfs -text

# Fonts
*.ttf filter=lfs diff=lfs merge=lfs -text
```

### 3.4. 最初のコミットとリモートリポジトリへのプッシュ

**アクション:** 最初のコミットを行い、ローカルリポジトリをGitHubなどのリモートリポジトリに接続します。

**プロセス:**
1. GitHub（または同様のサービス）上で、新しい空のリポジトリを作成します
   - こちらで独自のREADMEやgitignoreを作成したため、これらのファイルで初期化しないでください
2. リポジトリのURLをコピーします
3. ローカルのターミナルで、必要なすべてのファイルをステージングします: `git add .`
4. ファイルをコミットします: `git commit -m "Initial project setup"`
5. リモートリポジトリを接続します: `git remote add origin <your-repository-url>`
6. 最初のコミットをプッシュします: `git push -u origin master` (または `main`)

> **バージョン管理設定の連携について**
> 
> このバージョン管理設定は、一見すると3つの独立した要素（UnityのForce Text設定、Gitの.gitignoreファイル、Git LFSの.gitattributesファイル）から成り立っているように見えます。しかし、これらは個別のベストプラクティスではなく、緊密に連携する一つのシステムを形成しています。
> 
> - **Force Text**は、Unity独自のバイナリ形式のシーンやプレハブを、テキストベースのYAMLに変換します。これにより、Gitの行単位の差分検出アルゴリズムが機能するようになります。
> - **.gitignore**は、Libraryフォルダのような巨大で不要な、あるいはマシン固有のフォルダをGitの追跡対象から完全に「不可視」にし、追跡されるのを防ぎます。
> - **LFSルールを持つ.gitattributes**は、追跡は必要だがバイナリ形式であるアセット（例: song.mp3）を、Gitに特別な方法（ファイル全体ではなくポインタを保存する）で扱うよう指示します。
> 
> これら3つの要素は、Gitのための完全な「データ管理戦略」を構成します。Force Textはテキストとして管理できる範囲を最大化し、.gitignoreは追跡が必要な対象を最小化し、.gitattributesは残された不可欠なバイナリ資産に対する堅牢なソリューションを提供します。
> 
> これらの一つが欠けると、バージョン管理戦略全体が損なわれます。Force Textを忘れるとシーンのマージが不可能になり、.gitignoreを忘れるとリポジトリが肥大化して使用不能になり、.gitattributesを忘れるとアセットによって同様の肥大化が起こります。この共生関係を理解することが、バージョン管理の問題を診断し、健全なリポジトリを維持するための鍵となります。

---

## パート4：プロジェクトアーキテクチャとディレクトリ構造

クリーンで論理的、かつ一貫性のあるディレクトリ構造は、プロフェッショナルなプロジェクトの証です。これにより、アセットの発見が容易になり、認知的な負荷が軽減され、AIコーディングパートナーとの効果的な共同作業に不可欠な基盤が築かれます。
### 4.1. クリーンなプロジェクト構造の理念

**基本原則:** 一貫性、発見可能性、そして関心の分離。

ここでは、高レベルではアセットタイプ別に整理しつつ、その中で機能別のグループ化も許容するハイブリッドな構造を採用します。
- 「名前にスペースを使用しない」という方針を厳格に守る
- Assetsのルートフォルダをクリーンに保つ
- 自作のアセットとサードパーティのアセットを分離する

### 4.2. コアディレクトリの設計図

**アクション:** Assetsディレクトリ内に、標準化されたトップレベルのフォルダ構造を作成します。

**理由:** この構造は、すべての開発者（人間とAIの両方）にとって、予測可能なプロジェクトの「地図」を提供します。これにより、プロジェクトのコード、サードパーティのパッケージ、そしてドキュメンテーションが明確に分離されます。

**構造:**

```Assets/
├── _Project/         # プロジェクトのコアファイル
├── _Docs/            # Claude Codeとチームのためのドキュメンテーション
├── Editor/           # Editor専用スクリプト
├── Plugins/          # この場所を要求するサードパーティ製プラグイン
└── ThirdParty/       # その他インポートしたアセット（Asset Storeなど）
```

### 4.3. _Projectフォルダ：コアワークスペース

**アクション:** `_Project`フォルダの内部構造を定義します。先頭のアンダースコア`_`は、ファイルリストの最上部に表示させ、アクセスを容易にするためのものです。

**理由:** ここは、我々が作成するすべてのカスタムアセットが格納される場所です。組織は主にアセットタイプ別に行われ、これは一般的で効果的な出発点です。

**構造:**

```Assets/_Project/
├── Animations/
├── Audio/
│   ├── Music/
│   └── SFX/
├── Fonts/
├── Materials/
├── Prefabs/
│   ├── Gameplay/
│   └── UI/
├── Scenes/
│   ├── _Sandbox/     # テストや実験用
│   ├── MainMenu.unity
│   └── Gameplay.unity
├── Scripts/
│   ├── Gameplay/
│   ├── Managers/
│   └── UI/
├── Shaders/
├── Sprites/
│   ├── Backgrounds/
│   ├── Notes/
│   └── UI/
└── Timeline/
```

### 4.4. _Docsフォルダ：Claude Codeのための頭脳

**アクション:** 専用のドキュメンテーションフォルダを作成します。

**理由:** これは、我々のAI支援ワークフローの基盤です。ドキュメンテーションは常に良い習慣ですが、この文脈では、開発ツールチェーンの機能的な一部となります。Claude Codeは、このフォルダ内のMarkdownファイルを参照するよう指示され、プロジェクトのアーキテクチャ、機能要件、コーディング規約に関するコンテキストを取得します。これにより、ドキュメンテーションは受動的な記録から、能動的な「プロンプトコンテキストプロバイダー」へと変貌します。

**構造:**

```Assets/_Docs/
├── Architecture.md      # システムのハイレベルな概要（GameManager, Inputなど）
├── CodingConventions.md # 命名規則、フォーマットなどのルール
└── Features/
    ├── Feature_NoteSpawning.md
    └── Feature_ScoreSystem.md
```

### 表2: コアプロジェクトのディレクトリ構造と目的

| ディレクトリ | 目的 | 主要な考慮事項 |
|------------|-----|-------------|
| **Assets/_Project/** | チームが作成したすべてのオリジナルでプロジェクト固有のアセットを格納します。これが我々の主要なワークスペースです。 | 先頭のアンダースコアにより、常にリストの最上部に表示されます。内部はアセットタイプ別に整理されています。 |
| **Assets/_Docs/** | AIとの連携に不可欠。 Claude Codeとチームのために、アーキテクチャ、機能、規約を定義するMarkdownファイルを格納します。 | これは単なるドキュメントではなく、AIのための機械可読なコンテキストプロバイダーです。 |
| **Assets/Editor/** | Unityの特殊フォルダ。この中のスクリプトはUnity Editor内でのみ実行され、最終的なゲームビルドには含まれません。 | カスタムツールやインスペクタに使用します。ランタイムコードをここに入れないでください。 |
| **Assets/ThirdParty/** | Asset Storeや他の外部ソースからダウンロードしたアセットを格納します。 | 外部コードを隔離し、コアプロジェクトファイルに影響を与えることなくパッケージの更新や削除を容易にします。 |
| **Assets/Plugins/** | もう一つのUnity特殊フォルダ。一部の古いアセットは、正しく機能するためにここに配置する必要があります。 | アセットのドキュメントで明示的に要求されている場合にのみ使用します。それ以外はThirdParty/を優先します。 |

---

## パート5：AI支援開発ワークフロー（Claude CodeによるVibe Coding）

このセクションでは、綿密に構築された環境を効率的な「Vibe coding」ワークフローに活用する方法を詳述します。鍵となるのは、AIに単に「コードを書いて」と依頼するのではなく、コンテキストを提供し、出力を反復的に洗練させていく構造化された対話へと移行することです。
### 5.1. 効果的なAI連携の原則

1. **人間が設計者、AIが実装者**
   - 我々の役割は「何を」「なぜ」を定義することです
   - アーキテクチャ上の決定を下し、インターフェースを定義し、要件を設定します
   - AIの役割は「どのように」を処理すること、つまり、定型的なコードの生成、ロジックの実装、反復的なタスクの実行です
   - 最終的なコードをレビューし、テストし、所有するのは常に我々の責任です

2. **コンテキストが王様**
   - コンテキストのないAIは、「幻覚」を見たり、汎用的で役に立たないコードを生成したりします
   - 我々が構築した環境（_Docsフォルダ、クリーンな構造）は、このコンテキストを提供するために設計されています

3. **反復的な洗練**
   - AIとの対話は会話として扱います
   - 高レベルの目標から始め、出力をレビューし、それを洗練させるために具体的で的を絞ったフィードバックを提供します
   - これが「編集-テスト-洗練ループ」です
### 5.2. 計画とプロンプトのサイクル

#### ステップ1：計画（人間主導）
新機能（例: スコアリングシステム）のコードを記述する前に、`Assets/_Docs/Features/`内に新しいMarkdownファイル（例: `Feature_ScoreSystem.md`）を作成します。このファイルに、平易な言葉で要件を概説します。

**計画例:**
```markdown
スコアリングシステムは、タイミングの正確さに基づいてポイントを付与する。

タイミングウィンドウを定義する：
- Perfect (±25ms)
- Great (±50ms)
- Good (±100ms)
- Miss

コンボカウンターはPerfect/Great/Goodヒットで増加し、Missでリセットされる。
```

#### ステップ2：プロンプト（コンテキスト提供）
Claude Codeにプロンプトを出す際、この計画を明示的に参照します。

**プロンプト例:**
```
あなたはシニアUnity C#開発者です。タスクはスコアリングシステムの実装です。

Assets/_Docs/Features/Feature_ScoreSystem.mdの計画を参照してください。
Assets/_Project/Scripts/Managers/内にScoreManager.csという新しいC#スクリプトを作成してください。
このスクリプトはシングルトンパターンとします。
定義されたタイミングウィンドウに基づいて、スコアとコンボを追跡するロジックを実装してください。
```
### 5.3. 編集-テスト-洗練ループの実践

#### ステップ1：生成
AIが最初の`ScoreManager.cs`スクリプトを生成します。

#### ステップ2：レビュー（人間主導）
生成されたコードを読みます：
- 我々の規約（CodingConventions.md）に従っているか？
- ロジックは健全か？
- 見落とされているエッジケースはないか？

#### ステップ3：テスト（人間主導）
プレースホルダーのスクリプトを作成するか、Unity Editorを使用してScoreManagerの関数を呼び出し、期待通りに動作するかを検証します。

テスト駆動開発（TDD）アプローチはさらに優れています。まずAIに失敗するテストを書かせ、次にそのテストをパスするコードを書かせるのです。

#### ステップ4：洗練（対話形式）
AIにフィードバックを提供します。

**洗練プロンプト例:**
```
ScoreManager.csのコードは動作しますが、シングルトンにpublic staticなインスタンスを使用しています。
CodingConventions.mdで定義されているように、private staticなインスタンスとpublicなプロパティアクセサを使用する形にリファクタリングしてください。
```

> **AIとのペアプログラミングの核心**
> 
> AIとのペアプログラミングにおいて、明確で具体的なコンテキストに基づいたプロンプトの重要性は繰り返し強調されています。プロジェクトのコンテキストが不足していると、「Vibe coding」のアプローチは失敗に終わる可能性があります。
> 
> 毎回大量のコードや説明文をプロンプトウィンドウに貼り付けるのは非効率的であり、コンテキストウィンドウの制限にも抵触します。しかし、Claude CodeのようなIDEやファイルシステムと統合された最新のAIツールは、ファイルを読み取るよう指示できます。これにより、プロンプトの「コンテキスト」部分を、構造化された専用ファイルにオフロードすることが可能になります。
> 
> `Architecture.md`や機能計画を含む`_Docs`フォルダは、もはや単なるドキュメンテーションではありません。それはAIのための、構造化され、クエリ可能な知識ベースとなります。「Feature_X.mdを参照し、CodingConventions.mdを遵守して機能Xを実装せよ」といったプロンプトは、すべてを一度に説明しようとするよりもはるかに強力で簡潔です。
> 
> これは、我々が「ドキュメンテーションAPI」を設計していることを意味します。`.md`ファイルの構造と明瞭さが、AIの出力品質に直接影響します。このアプローチは、テクニカルライティングと計画という規律を、単なるプロジェクト管理タスクから、AI支援ワークフローにおける中核的なソフトウェアエンジニアリングの実践へと昇華させます。優れた計画書は、今や優れたインターフェース定義と同等の重要性を持つのです。
### 5.4. プロジェクトのREADME.md作成

**アクション:** プロジェクトのルートディレクトリに、包括的な`README.md`ファイルを作成します。

**理由:** READMEはプロジェクトの玄関口です。チームに参加するすべての人（未来の自分自身やAIを含む）にとって、主要な情報源として機能します。高レベルの概要、セットアップ手順、そしてより詳細なドキュメントへのリンクを提供すべきです。

**内容の概要:**
1. **プロジェクト名とロゴ**
2. **説明** - ゲームがどのようなものかの簡単な要約
3. **プロジェクトのステータス** - （例: 開発中、プロトタイプ段階）
4. **はじめに / インストール** - 新規開発者がリポジトリをクローンし、プロジェクトを正しく開くための手順（必要なUnity LTSバージョンを明記）
5. **プロジェクト構造の概要** - ここにコアプロジェクトのディレクトリ構造の表（表2）を埋め込み、主要フォルダの目的を説明します
6. **AI連携ワークフロー** - 「計画-プロンプト-洗練」サイクルを簡単に説明し、ユーザー（およびAI）を詳細な計画のために_Docsフォルダへ誘導します
7. **主要連絡先 / 作者**

---

## 結論

### 達成事項の要約

本ドキュメントで詳述した手順により、プロフェッショナル水準の開発環境が、安定したLTS基盤の上に確立されました。

- プロジェクトはGitとGit LFSによる厳格なバージョン管理下にあり、将来のリポジトリ問題を未然に防ぐ体制が整っています
- 整理された、拡張性のあるディレクトリ構造が実装され、これは組織化を促進するだけでなく、AI開発パートナーであるClaude Codeに構造化されたコンテキストを提供するという重要な役割も果たします

### 次のステップ

次の開発フェーズでは、この堅牢なセットアップを活用し、パート5で定義されたAI支援ワークフローに従って、コアとなるゲームプレイメカニクス（例: ノーツのスポーン、入力処理）の実装を開始します。

基盤は整いました。ここから創造的な作業が始まります。
