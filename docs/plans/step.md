# Claude Codeを活用したVibe Codingによる4レーンリズムゲームデモ開発手順書

## はじめに

本レポートは、Unity開発環境のセットアップから、AIコーディングアシスタント「Claude」を活用した「Vibe Coding」ワークフローを用いて、実際にプレイ可能な4レーンのリズムゲームデモを制作するための、網羅的かつ専門的なステップバイステップの手順書である。

現代のゲーム開発において、AIの活用は単なる補助ツールを超え、開発プロセスそのものを変革する可能性を秘めている。「**Vibe Coding**」とは、厳密な計画なしに、開発者の直感や大まかな目標に基づき、自然言語プロンプトを用いてAIにアイデアやコードスニペットを生成させ、その場で調整を加えながら開発を進める手法である。このアプローチは、特にプロトタイピング段階において、アイデアを迅速に具現化し、イテレーションサイクルを加速させる強力な武器となる。

### プロフェッショナルな開発基盤の重要性

本手順書は、単にコードの生成を指示するだけでなく、プロフェッショナルな開発ワークフローの確立を重視する。これには、以下の要素が含まれる：

- 安定性の高いUnityバージョンの選定
- バージョン管理システム（GitおよびGit LFS）の導入
- スケーラブルなプロジェクト構造の設計

これらの基盤を固めることが、後の開発フェーズにおける手戻りを減らし、特にチームでの共同作業やAIツールとの連携において、円滑な進行を保証する鍵となる。

### 対象読者

基本的なプログラミング知識を有し、Unityでのゲーム開発に意欲的な開発者、特にリズムゲームという特有の技術的課題（精密なタイミング同期など）に挑み、かつAI支援開発という最先端のワークフローを取り入れたいと考える「意欲的な開発者」を想定している。

### 習得目標

本手順書を通じて、読者は以下の知識とスキルを習得することを目的とする：

- 安定性と拡張性を考慮したUnity開発環境の構築手法
- Vibe Codingの実践的アプローチと、効果的なAIプロンプトエンジニアリングの原則
- リズムゲームの根幹をなす、サンプル精度でのオーディオ同期技術
- ScriptableObjectを活用した柔軟なデータ駆動型設計
- 基本的なゲームループ（ノーツの生成、入力判定、スコアリング）の実装
- ゲームの完成度を高めるための応用機能（長押しノーツ、視覚的フィードバック）の実装
- 完成したデモをビルドし、外部プラットフォームで共有するための最終工程

### 手順書の構成

各章では、AIにコーディングを依頼する「**Vibe Codingタスク**」と、開発者がUnityエディタ上で直接操作を行う「**Unityエディタタスク**」を明確に区別し、理論と実践を両立させながら解説を進める。

---

# Part I: プロジェクトの基盤と専門的セットアップ

この最初のパートでは、単にプロジェクトを開始するのではなく、安定性、スケーラビリティ、そして共同作業を最初から見据えた、プロフェッショナル水準の開発環境を構築する。この予防的なアプローチは、プロジェクトのライフサイクル後半で頻繁に発生するバージョン管理、依存関係、プロジェクト構成に関する一般的な落とし穴を防ぐために不可欠である。

## Chapter 1: 最新のUnity開発環境

### 1.1. Unity Hubのインストールと最適なLTSバージョンの選定

開発の第一歩は、Unity Editorのバージョンとプロジェクトを管理するための中核ツールであるUnity Hubのインストールから始まる。

1. Unity公式サイトから、使用しているオペレーティングシステム（Windows, macOS, Linux）に対応したインストーラーをダウンロードし、インストールを実行する

#### Editorバージョンの選定

次に、極めて重要なのがEditorバージョンの選定である。Unityは以下の2つのリリースを提供している：

- **Tech Stream**: 新機能を積極的に導入するが、不安定な可能性がある
- **LTS（Long-Term Support）**: 安定性を重視し、リリースから2年間のサポートが保証されている

**推奨事項:**
- 新規プロジェクトでは最新のLTSバージョンを選択
- マイナーバージョンがいくつか進んだLTSを選ぶ（例：2022.3.0f1ではなく2022.3.7f1）

**インストール手順:**
1. Unity Hubの「Installs」タブから「Install Editor」を選択
2. 「Official releases」の中から適切なLTSバージョンを選択
3. Visual Studioモジュールも同時にインストールしておく
### 1.2. Unity IDの作成とライセンス管理

Unity Hubを使用し、アセットストアへのアクセスやライセンスを管理するためには、Unity IDが必須である。

**アカウント作成手順:**
1. Unity Hubの初回起動時、または右上の人型アイコンからサインイン画面にアクセス
2. 「Create account」または「create one」を選択
3. 必要情報を入力：
   - メールアドレス
   - パスワード
   - ユーザー名
   - フルネーム
4. 利用規約に同意してIDを作成
5. 登録メールアドレスに届く確認メールのリンクをクリックして認証完了

**ライセンスの有効化:**
1. Unity HubでサインインしてUnity Hub右上の歯車アイコンから「License Management」を選択
2. 「ACTIVATE NEW LICENSE」をクリック
3. 「Unity Personal」を選択（個人学習や小規模プロジェクトに適している）
4. 専門的な業務で使用しない旨の項目にチェック

> **注意**: Personalライセンスは年間収益10万ドル未満の個人・組織が対象です
### 1.3. バージョン管理の統合：プロフェッショナルの第一歩 (Git & Git LFS)

現代の開発ワークフローにおいて、バージョン管理システム（VCS）の導入は選択肢ではなく**必須事項**である。Unityプロジェクトを作成する前に、VCSのセットアップを完了させることが、クリーンで効率的なプロジェクト管理の鍵となる。

#### Git LFSの重要性

Unityプロジェクト特有の大容量バイナリファイル（テクスチャ、オーディオ、3Dモデルなど）を効率的に扱うため、Git Large File Storage (LFS) が必要である。Git自体はテキストベースのコード差分管理に最適化されているため、バイナリファイルをそのままリポジトリに含めると:

- ✗ リポジトリが急速に肥大化
- ✗ クローンやフェッチのパフォーマンスが著しく低下

Git LFSは、これらの大容量ファイルをリポジトリ内ではポインタとして管理し、実ファイルは別のストレージサーバーに保存することで、この問題を解決する。

#### セットアップ手順

**1. Gitのインストール**
- Git公式サイトからダウンロードし、システムにインストール

**2. Git LFSの初期化**
```bash
git lfs install
```

**3. プロジェクト用フォルダの作成とリポジトリ初期化**
```bash
mkdir MyRhythmGame
cd MyRhythmGame
git init
```

**4. リモートリポジトリとの接続**
GitHubやGitLabなどのリモートリポジトリサービスに新しいリポジトリを作成し、ローカルリポジトリと接続しておく。
### 1.4. Unityに不可欠な.gitignoreと.gitattributesの作成

Gitリポジトリの初期化後、Unityプロジェクトを作成する前に、2つの重要な設定ファイルを作成する。この手順を踏むことで、最初のコミットから不要なファイルを除外し、必要なファイルを正しくLFSで追跡できる。

#### .gitignoreの作成

.gitignoreファイルは、Gitにバージョン管理から除外すべきファイルやフォルダを指示する。Unityは、ローカルマシン固有のキャッシュや一時ファイルを含むLibrary、Temp、Logsといったフォルダを自動生成する。これらをリポジトリに含めると、無駄なデータで肥大化し、チーム開発時には深刻なマージコンフリクトを引き起こす原因となる。

**除外すべきUnityファイル/フォルダ:**

| パターン | 説明 |
|----------|------|
| `/[Ll]ibrary/` | Unityがアセットのインポート情報やキャッシュを保存。プロジェクトで最も巨大になりうるフォルダ |
| `/[Tt]emp/` | ビルドプロセス中などに使用される一時ファイル |
| `/[Oo]bj/` | コンパイル時に生成される中間オブジェクトファイル |
| `/[Bb]uild/` | ビルド成果物が格納されるフォルダ |
| `/[Ll]ogs/` | Unityエディタのログファイル |
| `/[Uu]serSettings/` | エディタのウィンドウレイアウトなど、ユーザー個別の設定 |
| `*.csproj` | Visual Studioのプロジェクトファイル（Unityによって自動生成） |
| `*.sln` | Visual Studioのソリューションファイル（Unityによって自動生成） |
| `*.suo` | Visual Studioのユーザーオプションファイル |
| `*.userprefs` | MonoDevelopのユーザー設定ファイル |

#### .gitattributesの作成

.gitattributesファイルは、特定のファイルパスに対してGitの属性を定義するために使用する。ここでは、Git LFSに追跡させるファイルタイプを指定する。

**LFSで管理すべきファイルタイプ:**

| 拡張子 | 説明 |
|--------|------|
| `*.jpg filter=lfs diff=lfs merge=lfs -text` | JPEG画像ファイル |
| `*.png filter=lfs diff=lfs merge=lfs -text` | PNG画像ファイル |
| `*.psd filter=lfs diff=lfs merge=lfs -text` | Photoshopファイル |
| `*.fbx filter=lfs diff=lfs merge=lfs -text` | 3Dモデルファイル（FBX形式） |
| `*.wav filter=lfs diff=lfs merge=lfs -text` | WAV音声ファイル |
| `*.mp3 filter=lfs diff=lfs merge=lfs -text` | MP3音声ファイル |
| `*.ogg filter=lfs diff=lfs merge=lfs -text` | OGG Vorbis音声ファイル |
| `*.asset merge=unityyamlmerge eol=lf` | Unityのアセットファイル |
| `*.unity merge=unityyamlmerge eol=lf` | Unityのシーンファイル |
| `*.prefab merge=unityyamlmerge eol=lf` | Unityのプレハブファイル |

#### 初回コミット

```bash
git add .gitignore .gitattributes
git commit -m "Initial commit: Configure Git for Unity project"
```

このプロフェッショナルな初期設定により、Unityプロジェクトはクリーンで効率的なバージョン管理の基盤の上に構築される。開発の初期段階でこの手順を踏むことは、将来の技術的負債を未然に防ぎ、プロジェクトの健全性を維持するための最良の実践である。

---

## Chapter 2: スケーラビリティのためのプロジェクト設計

### 2.1. 堅牢なフォルダ構造の確立

プロジェクトが成長するにつれて、アセットの数は指数関数的に増加する。首尾一貫したフォルダ構造は、ファイルを見つけやすくし、チームメンバー間の混乱を防ぎ、プロジェクト全体の保守性を向上させるために不可欠である。唯一絶対の正解は存在しないが、ベストプラクティスとして広く受け入れられているのは、アセットの種類や機能によって整理する方法である。

本プロジェクトでは、以下の構造を推奨する。これは、自作のアセットとサードパーティ製のアセットを明確に分離し、プロジェクトの核となる要素を一箇所に集約することを目的としている。

```
Assets/
├── _Project/ （アンダースコアは、フォルダをリストの先頭に表示させるための慣例）
│   ├── Art/
│   │   ├── Sprites/
│   │   ├── Fonts/
│   │   └── Materials/
│   ├── Audio/
│   │   ├── Music/
│   │   └── SFX/
│   ├── Data/
│   │   └── SongCharts/ （ScriptableObjectを格納）
│   ├── Prefabs/
│   ├── Scenes/
│   └── Scripts/
│       ├── Gameplay/
│       ├── Managers/
│       ├── UI/
│       └── Data/
├── _ThirdParty/（Asset Storeからインポートしたアセットはここに格納）
├── Editor/ （エディタ拡張スクリプト用の特殊フォルダ）
├── Resources/ （動的ロード用アセットの特殊フォルダ）
└── Sandbox/ （実験用のシーンやアセットを格納。バージョン管理からは除外してもよい）
```

命名規則も同様に重要である。ファイル名やフォルダ名にはスペースを使用せず、PascalCaseまたはcamelCaseで統一する。これにより、コマンドラインツールとの互換性が保たれ、可読性が向上する。

### 2.2. Unityプロジェクトの作成：2D (URP) コアテンプレート

前章で準備した環境（Gitリポジトリとフォルダ構造）の中に、Unityプロジェクトを作成する。

**Unityエディタタスク:**

1. Unity Hubを起動し、「Projects」タブで「New project」をクリックする
2. Editor Versionには、Chapter 1でインストールしたLTSバージョンを選択する
3. テンプレート一覧から「**2D (URP) Core**」を選択する
   - このテンプレートを選択する理由は、Universal Render Pipeline (URP) が標準で設定されるためである
   - URPは、Unityの最新のレンダリングパイプラインであり、高いパフォーマンスと柔軟なカスタマイズ性を提供する
   - 特に2D開発においては、2Dライティングやカスタムシェーダーといった高度な視覚表現を容易に実現できるという利点がある
4. Project Nameを入力し、LocationにはChapter 1で作成したGitリポジトリのフォルダを指定する
5. 「Create project」をクリックしてプロジェクトを作成する
6. プロジェクトが作成されたら、2.1で設計したフォルダ構造をAssetsフォルダ内に作成する

### 2.3. 2Dリズムゲームのための初期シーンとカメラ設定

**Unityエディタタスク:**

1. **Assets/_Project/Scenes/**フォルダ内に、新しいシーンを作成し、**GameScene**と命名する
2. GameSceneを開き、Hierarchyウィンドウにデフォルトで存在する「**Main Camera**」を選択する
3. Inspectorウィンドウで、Cameraコンポーネントの設定を変更する：
   - **Projection**を「**Orthographic**」に設定する
   - これにより、カメラは遠近感のない平行投影でシーンをレンダリングし、2Dゲームに適した表示となる
4. URP環境下では、Cameraコンポーネントに追加の「**URP Universal Additional Camera Data**」が付与されている
   - **Render Type**が「**Base**」になっていることを確認する
   - これは、このカメラがシーンの主たるレンダリングを担当することを示す
5. **Background Type**を「**Solid Color**」に設定し、背景色を好みの暗い色（例：濃いグレーや黒）に変更する
   - これにより、ノーツやUIの視認性が向上する
6. **Stack**セクションは、複数のカメラの描画結果を重ね合わせるために使用するが、このデモでは単一のカメラで十分なため、設定は不要である
7. シーンを保存する

これで、リズムゲーム開発のためのクリーンでスケーラブルなプロジェクト基盤が整った。次のパートでは、この基盤の上に、Vibe Codingを活用してゲームのコアメカニクスを構築していく。

---

# Part II: Vibe Codingによるコアゲームループの構築

このパートでは、プロジェクトの心臓部となるゲームプレイの基本ループを構築する。AI支援開発手法「Vibe Coding」を本格的に導入し、リズムゲームの根幹をなすタイミング管理、譜面データ、ノーツの生成と制御、そしてプレイヤーの入力と判定システムを実装していく。

各章では、Claudeへのプロンプトによるコード生成と、Unityエディタ上での具体的な設定作業を交互に行い、実践的な開発フローを体験する。

## Chapter 3: ゲームの心臓部 - タイミングとオーディオ同期

### 3.1. Vibe Codingの哲学：意図から実装へ

Vibe Codingは、コードを一行も書かずにアプリケーションを完成させる魔法の杖ではない。それは、開発者とAIアシスタントとの間の、協調的で反復的な対話プロセスである。開発者の役割は、マイクロマネジメント的なコード記述から、アーキテクチャ設計、システム間の連携定義、そしてAIへの明確な指示（プロンプトエンジニアリング）へとシフトする。

効果的なプロンプトを作成するための基本原則は以下の通りである：

- **具体性 (Specificity)**: 「Xのための関数を書いて」のような曖昧な指示ではなく、「整数のリストを受け取り、偶数のみを返すPython関数を書いて」のように、入力、出力、処理内容を明確に定義する
- **文脈の提供 (Context)**: AIはプロジェクトの全体像を知らない。関連するコードの一部や、従うべき設計パターン、既存のクラス名などを提供することで、生成されるコードの精度と一貫性が劇的に向上する
- **構造の提示 (Scaffolding)**: AIに実装を任せる前に、クラスの骨格（フィールド、メソッドのシグネチャ、処理の概要を記述したコメントなど）を先に記述する。これにより、AIは開発者の意図を正確に理解し、構造に沿ったコードを生成できる
- **対話と反復 (Dialogue and Iteration)**: 最初の出力が完璧であることは稀である。生成されたコードをレビューし、修正や改善のためのフィードバックをAIに与える。この対話的なループこそがVibe Codingの核心である

### 3.2. AIプロンプティング：マスターConductorスクリプトの作成

**Conductor（指揮者）**スクリプトは、ゲーム内のすべてのタイミングの「信頼できる唯一の情報源（Single Source of Truth）」となる。このスクリプトの精度が、リズムゲームのプレイフィールを決定づける。

**Vibe Codingタスク:** Claudeに以下のプロンプトを段階的に与え、Conductor.csスクリプトを生成させる。

#### プロンプト 1: 基本構造の生成

```
Unity用のC#スクリプト「Conductor」を作成してください。
このスクリプトは、ゲーム内に常に単一のインスタンスしか存在しないように、シングルトンパターンを実装してください。

以下のpublicなプロパティを持つようにしてください：
- songBpm: 曲のBPM (beats per minute) を示すfloat型
- firstBeatOffset: 最初のビートが始まるまでのオフセット時間（秒）を示すfloat型
- songSource: 曲を再生するためのAudioSourceコンポーネントへの参照

また、このスクリプトはシングルトンインスタンスを外部から参照するための `public static Conductor instance` プロパティを持つ必要があります。
Awakeメソッドでシングルトンの初期化処理を実装してください。
```

#### プロンプト 2: オーディオ同期と時間計測の追加

```
先ほど作成した`Conductor`スクリプトに機能を追加します。

曲の再生を開始するための `PlaySong()` というpublicメソッドを追加してください。
このメソッドが呼ばれたら、`AudioSettings.dspTime` を使用して、曲の再生が開始された正確な時刻を `dspSongTime` というプライベートなfloat型変数に記録してください。その後、`songSource.Play()` を呼び出して曲を再生します。

さらに、以下の2つのpublicなプロパティを追加してください。これらは `get` アクセサのみを持ち、常に最新の値を計算して返すようにします。
1. `songPositionInSeconds`: 現在の曲の再生位置を秒単位で返します。`AudioSettings.dspTime - dspSongTime` で計算します。
2. `songPositionInBeats`: 現在の曲の再生位置をビート単位で返します。`songPositionInSeconds` を1ビートあたりの秒数で割ることで計算します。1ビートあたりの秒数は `60f / songBpm` で求められます。

これらのプロパティは、ゲームの他の部分が正確なタイミング情報を取得するために使用します。
```

### 3.3. 深掘り：なぜAudioSettings.dspTimeが不可欠なのか

リズムゲーム開発において、タイミングの正確性はゲームの成否を分ける最も重要な要素である。多くの初心者が陥る罠は、フレームレートに依存するTime.timeやTime.deltaTimeをタイミングの基準として使用してしまうことだ。しかし、これは致命的な設計ミスに繋がる。

UnityのUpdateメソッドは毎フレーム呼ばれるが、その間隔は一定ではない。デバイスの負荷状況によってフレームレートは変動するため、Time.deltaTime（前フレームからの経過時間）を積算していく方法では、必ず誤差が蓄積していく。

一方、AudioSettings.dspTimeは、オーディオハードウェアが処理したサンプル数に基づく、非常に高精度なタイマーである。これはゲームのフレームレートとは独立したスレッドで更新されるため、フレームのドロップや遅延の影響を受けず、再生されている音楽と完全に同期した時間を取得できる。

| タイミング機構 | 仕組み | 利点 | リズムゲームにおける欠点 |
|---------------|--------|------|------------------------|
| Time.deltaTime | 前のフレームから現在のフレームまでの経過時間（秒） | フレームレートに依存した動き（例：一定速度での移動）の実装が容易 | フレームレートの変動に直接影響されるため、時間経過と共に誤差が蓄積する。音楽との同期が徐々にずれていく |
| Time.time | ゲーム開始からの経過時間（秒）。Time.timeScaleの影響を受ける | ゲーム全体の経過時間を簡単に取得できる | Time.deltaTimeの積算値であり、同様にフレームレートの変動による誤差を含む。一時停止などでtimeScaleを変更すると時間が止まる |
| AudioSettings.dspTime | オーディオシステムの内部タイマー。オーディオサンプル処理に基づいて更新される高精度な時間（秒） | フレームレートから独立しており、極めて正確。音楽の再生位置と完全に同期する。Time.timeScaleの影響を受けない | オーディオシステムに依存するため、純粋なゲームロジックのタイマーとしては直感的でない場合がある |

**結論として、ノーツの生成、移動、判定など、音楽との同期が求められるすべての処理は、AudioSettings.dspTimeを基準としなければならない。**

### 3.4. Unityエディタタスク：AudioSourceの設定

1. Hierarchyウィンドウで右クリックし、「Create Empty」を選択して空のGameObjectを作成し、**Conductor**と命名する
2. Conductorオブジェクトを選択し、Inspectorウィンドウで「Add Component」をクリック
3. 生成した**Conductor.cs**スクリプトをアタッチする
4. 同様に、「Add Component」から「**Audio Source**」を追加する
5. プロジェクトの**Assets/_Project/Audio/Music/**フォルダに、使用したい音楽ファイル（.wav,.mp3,.oggなど）をインポートする
6. ConductorオブジェクトのAudio SourceコンポーネントにあるAudioClipフィールドに、インポートした音楽ファイルをドラッグ＆ドロップで割り当てる
7. **Play On Awake**のチェックを外す。これにより、PlaySong()メソッドが呼ばれるまで音楽が再生されないようにする

---

## Chapter 4: 譜面の設計 - データ構造

### 4.1. AIプロンプティング：NoteDataとSongData ScriptableObjectの設計

ゲームのロジックとデータを分離することは、優れたソフトウェア設計の基本原則である。リズムゲームの「譜面」データは、曲ごとに独立しており、再利用可能であるべきだ。このようなデータコンテナとして、UnityではScriptableObjectが非常に強力なツールとなる。

ScriptableObjectは、シーン内のGameObjectに依存しないアセットとしてプロジェクトに保存でき、複数のオブジェクトから参照したり、エディタ上で簡単に編集したりすることが可能である。

**Vibe Codingタスク:**

#### プロンプト 1: 個々のノーツ情報を保持するクラスの作成

```
Unity用のC#スクリプトを作成してください。
このスクリプトは、個々のノーツの情報を保持するための、`MonoBehaviour`を継承しない単純なデータコンテナクラス `NoteData` を定義します。

`NoteData`クラスは、``属性を持つ必要があります。これにより、Inspector上で表示・編集が可能になります。

クラス内には以下のpublicなフィールドを定義してください：
- `laneIndex`: ノーツが出現するレーン番号（0から3の整数）。
- `timeToHit`: 曲の開始からノーツを叩くべきタイミング（ビート単位）。
このNoteDataクラスは、一つのノーツが持つべき最小限の情報、すなわち「いつ」「どこに」出現するかを定義する。
```

#### プロンプト 2: 曲全体の情報をまとめるScriptableObjectの作成

```
次に、`ScriptableObject`を継承するC#スクリプト「SongData」を作成してください。
このスクリプトは、1曲分の譜面データをまとめるアセットとして機能します。

以下のpublicなフィールドを定義してください：
- `songClip`: 曲のオーディオクリップ (`AudioClip`型)
- `bpm`: 曲のBPM (`float`型)
- `notes`: 曲のすべてのノーツ情報。先ほど定義した`NoteData`クラスのリスト (`List<NoteData>`)

さらに、UnityエディタのAssetsメニューから簡単にこのアセットを作成できるように、`CreateAssetMenu`属性をクラス定義の上に追加してください。
```

### 4.2. Unityエディタタスク：サンプル譜面アセットの作成と入力

1. **Assets/_Project/Data/SongCharts/**フォルダ内で右クリックする
2. メニューに`[CreateAssetMenu]`属性によって追加された「**Rhythm Game > Song Data**」を選択する
3. 新しいSongDataアセットが作成されるので、**SampleSong**のような名前に変更する
4. SampleSongアセットを選択し、Inspectorウィンドウでプロパティを設定する：
   - **Song Clip**フィールドに、Chapter 3でインポートした音楽ファイルをドラッグ＆ドロップする
   - **Bpm**フィールドに、その曲のBPMを入力する
   - **Notes**リストの右下にある「**+**」ボタンをクリックして、ノーツデータを追加する
   - 各要素を展開し、テスト用の**Lane Index**（0～3）と**Time To Hit**（ビート単位）をいくつか手動で入力する
     - 例：4ビートの曲なら、Time To Hitが0, 1, 2, 3といった値になる

この作業により、ゲームロジックが参照する具体的な譜面データが完成する。**ScriptableObject**を使用しているため、プログラマーでなくても、デザイナーがこのアセットを編集するだけで譜面を調整できる。

---

## Chapter 5: ノーツの生命 - 生成と移動

### 5.1. Unityエディタタスク：Noteプレハブの設計

**プレハブ（Prefab）**は、設定済みのGameObjectを再利用可能なアセットとして保存するUnityの機能である。ゲーム中に多数出現するノーツは、プレハブとして作成するのが最適だ。

**Unityエディタタスク：**
1. Hierarchyウィンドウで、2Dオブジェクト（**2D Object > Sprites > Square**など）を作成し、**Note**と命名する
2. Noteオブジェクトに、当たり判定用のコンポーネントを追加する：
   - 「**Add Component**」から「**Box Collider 2D**」を選択
   - Box Collider 2Dコンポーネントの**Is Trigger**にチェックを入れる
   - これにより、物理的な衝突を起こさず、他のオブジェクトが領域に侵入したことだけを検出するトリガーとして機能する
3. トリガーイベントを正しく発生させるためには、少なくとも衝突するオブジェクトの一方にRigidbodyが必要である：
   - Noteオブジェクトに「**Rigidbody 2D**」コンポーネントを追加する
   - Rigidbody 2DコンポーネントのBody Typeを「**Kinematic**」に設定する
   - これにより、物理演算（重力など）の影響を受けなくなり、スクリプトによる制御のみで動かすことができる
4. 設定が完了したNoteオブジェクトを、HierarchyウィンドウからAssets/_Project/Prefabs/フォルダにドラッグ＆ドロップする
   - これにより、**Noteプレハブ**が作成される
   - 元のNoteオブジェクトはHierarchyから削除してよい

### 5.2. AIプロンプティング：NoteSpawnerとNoteControllerスクリプトの開発

**Vibe Codingタスク：**

#### プロンプト 1: ノーツを生成するNoteSpawner

```
Unity用のC#スクリプト「NoteSpawner」を作成してください。

このスクリプトは、譜面データに基づいて適切なタイミングでノーツを生成する役割を担います。

以下のpublicなフィールドが必要です：
- `songData`: 現在再生中の曲の`SongData`アセットへの参照
- `notePrefab`: 生成するノーツの`GameObject`プレハブへの参照
- `laneSpawns`: 4つのレーンの生成開始位置を示す`Transform`の配列

内部的に、次に生成すべきノーツのインデックスを追跡するための`notesIndex`というint型変数を持ってください。

`Start`メソッドで、`Conductor.instance.PlaySong()`を呼び出して曲の再生を開始します。

`Update`メソッドでは、以下のロジックを実装してください：
1. `songData.notes`リストの最後までチェックが終わっていないか確認します
2. `Conductor.instance.songPositionInBeats`（現在のビート位置）を取得します
3. 次に生成すべきノーツ (`songData.notes[notesIndex]`) の `timeToHit` を確認します
4. もし `timeToHit` が、現在のビート位置から「ノーツが画面上部から判定ラインまで到達するのにかかるビート数」を引いた値以下になったら、そのノーツを生成するタイミングです
   - 簡単のため、ここでは「ノーツが画面をスクロールするのに一定のビート数がかかる」と仮定します
   - 例：`timeToHit - 4.0f <= Conductor.instance.songPositionInBeats` のような条件
5. ノーツを生成する際は、`Instantiate`メソッドを使用します。`notePrefab`を、`noteData.laneIndex`に対応する`laneSpawns`の位置に生成します
6. ノーツを生成したら、`notesIndex`をインクリメントして、次のノーツをチェックするようにします
```

#### プロンプト 2: ノーツの動きを制御するNoteController

```
Unity用のC#スクリプト「NoteController」を作成してください。
これは`Note`プレハブにアタッチされ、個々のノーツの動きを制御します。

publicな`scrollSpeed`というfloat型フィールドを持ってください。

`Update`メソッドで、`transform.position`をy軸の負の方向に `scrollSpeed * Time.deltaTime` だけ移動させてください。

また、この`NoteController`は、判定ラインを通り過ぎた場合に自分自身を破棄し、スコアマネージャーに「ミス」を通知する機能も持つべきです。
画面外に出たことを判定するため、y座標が一定の値（例えば-10.0f）より小さくなったら、`ScoreManager.instance.NoteMissed()`を呼び出し、`Destroy(gameObject)`で自身を破棄する処理を追加してください。
```
### 5.3. Unityエディタタスク：レーンマネージャーの組み立て

1. **NoteSpawnerの設定**
   - Hierarchyに空のGameObjectを作成し、**NoteSpawner**と命名する
   - **NoteSpawner.cs**をアタッチする
   - NoteSpawnerの子オブジェクトとして、4つの空のGameObjectを作成し、**SpawnPoint_0**から**SpawnPoint_3**と命名する
   - これらを画面上部の各レーンに対応する位置に配置する

2. **NoteSpawnerの設定**
   - NoteSpawnerオブジェクトを選択し、Inspectorで各フィールドを設定する：
     - **Song Data**に、作成したSampleSongアセットをドラッグ＆ドロップする
     - **Note Prefab**に、作成したNoteプレハブをドラッグ＆ドロップする
     - **Lane Spawns**配列のサイズを4に設定し、それぞれにSpawnPoint_0からSpawnPoint_3のTransformをドラッグ＆ドロップする

3. **Noteプレハブの設定**
   - Noteプレハブを選択し、**NoteController.cs**をアタッチする
   - **scrollSpeed**を適切な値（例：5.0）に設定する

---

## Chapter 6: プレイヤーの介入と判定

### 6.1. Unityエディタタスク：判定ラインのトリガーと入力設定

1. Hierarchyに、判定ラインとなる視覚的なスプライトオブジェクトを作成し、**JudgmentLine**と命名する
2. 各レーンの下部（プレイヤーがノーツを叩く位置）に、空のGameObjectを4つ作成し、**JudgmentTrigger_0**から**JudgmentTrigger_3**と命名する
3. これらのJudgmentTriggerオブジェクトに**BoxCollider2D**を追加し、**Is Trigger**にチェックを入れる
4. サイズを調整して、ノーツが通過する際に確実に反応する範囲を確保する

### 6.2. AIプロンプティング：InputManagerとScoreManagerスクリプト

**Vibe Codingタスク:**

#### プロンプト 1: 入力を処理するInputManager

```
Unity用のC#スクリプト「InputManager」を作成してください。

このスクリプトはプレイヤーのキー入力を検出し、ノーツの判定を行います。

`Update`メソッド内で、4つのレーンに対応するキー（例：D, F, J, K）が押されたかを `Input.GetKeyDown` でチェックしてください。

キーが押されたら、対応するレーンの判定ゾーンにノーツが存在するかどうかを確認する必要があります。
この確認のために、`JudgmentTrigger`という別のスクリプトが存在すると仮定します。
キーが押されたレーンに対応する`JudgmentTrigger`オブジェクトから、現在トリガー内にあるノーツの情報を取得し、もしノーツが存在すれば、そのノーツを破壊 (`Destroy`) して、`ScoreManager.instance.NoteHit()`を呼び出してください。
```

#### プロンプト 2: 判定ロジックを担うJudgmentTrigger

```
`InputManager`を補助するためのC#スクリプト「JudgmentTrigger」を作成してください。
これは各レーンの判定ゾーンオブジェクトにアタッチされます。

内部に、現在トリガー内に存在するノーツを保持するための `List<GameObject> notesInTrigger` を持ってください。

`OnTriggerEnter2D`メソッドを実装し、ノーツがトリガーに入ってきたら、そのノーツのGameObjectをリストに追加してください。
`OnTriggerExit2D`メソッドを実装し、ノーツがトリガーから出ていったら、リストからそのGameObjectを削除してください。

`GetHittableNote()`というpublicメソッドを作成してください。これはリスト内にノーツがあれば、リストの最初のノーツを返し、なければnullを返します。
`RemoveNote(GameObject note)`というpublicメソッドも作成し、指定されたノーツをリストから削除する機能を持たせてください。
```

#### プロンプト 3: スコアとコンボを管理するScoreManager

```
シングルトンパターンを実装したC#スクリプト「ScoreManager」を作成してください。

このスクリプトは、プレイヤーのスコアとコンボ数を管理します。
- `score` (int)
- `combo` (int)

以下のpublicメソッドを実装してください：
- `NoteHit()`: スコアを100点加算し、コンボを1増やします。
- `NoteMissed()`: コンボを0にリセットします。

スコアやコンボが更新された際にUIを更新する処理も後で追加しますが、まずは基本的なロジックを実装してください。
```

### 6.3. システムの統合：入力、ノーツ、スコアの連携

**Unityエディタタスク:**

1. Hierarchyに空のGameObjectを**GameManagers**として作成する
2. GameManagersの子として、**InputManager**と**ScoreManager**という空のGameObjectを作成し、それぞれに対応するスクリプトをアタッチする
3. JudgmentTrigger_0からJudgmentTrigger_3の各オブジェクトに**JudgmentTrigger.cs**をアタッチする

**Vibe Codingタスク (リファイン):**

AIにInputManagerを修正させる。「InputManagerが各JudgmentTriggerスクリプトへの参照を持てるように、publicなJudgmentTriggerの配列を追加してください。キーが押されたら、配列から対応するインデックスのJudgmentTriggerにアクセスし、GetHittableNote()を呼び出すようにロジックを修正してください。」

> **注**: これで、プレイヤーの入力が判定ゾーン内のノーツと連携し、スコアシステムに結果を通知する一連の流れが完成する。この統合プロセスは、個別に機能するコンポーネントを組み合わせて一つのゲームシステムを構築する、開発における重要なステップである。開発者はシステム間の情報の流れを設計し、AIはその設計に基づいた具体的な接続コードを実装する、という役割分担がVibe Codingの効率性を最大限に引き出す。

---

# Part III: デモの洗練 - 高度な機能とフィードバック

コアとなるゲームプレイのループが完成した今、このパートではデモに深みと満足感を加えるための洗練作業に焦点を当てる。単なるタップだけでなく、長押しを要求するノーツを導入し、プレイヤーのアクションに対する視覚的・聴覚的なフィードバックを強化することで、より魅力的で完成度の高い体験を構築する。

## Chapter 7: 高度なノーツタイプの実装：長押しノーツ

### 7.1. AIプロンプティング：NoteDataとNoteControllerのホールドロジックへの進化

長押しノーツ（ホールドノーツ、ロングノーツとも呼ばれる）は、多くのリズムゲームにおける基本的な要素である。これを実装するには、まずデータ構造を拡張し、次に入力処理とノーツの振る舞いを変更する必要がある。

**Vibe Codingタスク:**

#### プロンプト 1: データ構造の拡張

```
既存の`NoteData.cs`スクリプトを修正してください。

まず、ノーツの種類を定義するための `public enum NoteType` を `NoteData` クラスの外（または別のファイル）に定義します。このenumは `Tap` と `Hold` の2つの値を持つようにします。

次に、`NoteData`クラスに以下の2つのpublicフィールドを追加してください：
- `noteType`: 先ほど定義した`NoteType`型のフィールド。
- `holdDurationInBeats`: `noteType`が`Hold`の場合にのみ意味を持つ、長押しの長さをビート単位で示す`float`型のフィールド。
```

#### プロンプト 2: 入力処理の拡張

```
`InputManager.cs`を修正し、長押しノーツに対応させます。

キーが押された(`Input.GetKeyDown`)際の処理に加えて、キーが押され続けている間(`Input.GetKey`)と、キーが離された時(`Input.GetKeyUp`)の処理を追加する必要があります。

長押しノーツの判定ロジックは複雑になります。以下のような状態を管理する変数を各レーンごとに持つ必要があります：
- `isHolding`: 現在、そのレーンで長押し中かどうかを示すbool値。

キーが押された時、判定ゾーンにあるノーツが`Hold`タイプであれば、`isHolding`をtrueにし、長押しを開始します。
キーが押され続けている間、`isHolding`がtrueであれば、長押しが継続していると判断します。
キーが離された時、`isHolding`がtrueであれば、長押しが終了したと判断し、成功判定を行います。`isHolding`をfalseに戻します。

このロジックを`InputManager`に組み込んでください。
このプロンプトは、より複雑な状態管理を要求するものであり、AIとの対話を通じてロジックを洗練させていく良い例となる。
```

### 7.2. Unityエディタタスク：9スライスによる視覚的に伸縮可能な長押しノーツ

長押しノーツは、その長さに応じて視覚的な長さが変わる必要がある。単純にスプライトをY軸方向に引き伸ばすと、ノーツの始点と終点のデザインが歪んでしまう。この問題を解決するのが「**9スライス**」というテクニックである。

9スライスは、一枚のスプライトを9つの領域（四隅、上下、左右、中央）に分割し、拡大・縮小時に各領域が異なる振る舞いをするように設定する機能である。これにより、四隅は変形せず、辺は一方向にのみ引き伸ばされ、中央は両方向に引き伸ばされるため、UIパネルや伸縮するオブジェクトの作成に非常に適している。

**Unityエディタタスク:**

1. 長押しノーツの「胴体」部分として使用するスプライトを用意する。このスプライトは、上下の端が丸みを帯び、中央部分が均一なデザインであることが望ましい
2. プロジェクトウィンドウでそのスプライトを選択し、Inspectorで「**Sprite Editor**」を開く
3. Sprite Editorウィンドウの左上にある「Sprite」ドロップダウンの隣にある「**Border**」フィールド（L, R, T, B）に値を入力するか、緑色の境界線をドラッグして、スプライトの伸縮しない部分（上下の端）と伸縮する部分（中央）を定義する
4. 「**Apply**」をクリックして変更を保存する
5. 新しいプレハブ**LongNote**を作成する。このプレハブは、ノーツの始点を示す「**Head**」スプライトと、胴体部分を示す「**Body**」スプライトの2つの子オブジェクトで構成される
6. 「Body」スプライトのSprite Rendererコンポーネントで、**Draw Mode**を「**Sliced**」または「**Tiled**」に設定する
   - 「Sliced」は滑らかに引き伸ばし、「Tiled」は中央部分をタイル状に繰り返す
   - 長押しノーツには「**Sliced**」が適している

**Vibe Codingタスク (リファイン):** AIにNoteControllerを修正させる。「NoteControllerがHoldタイプのノーツを扱う場合、holdDurationInBeatsに基づいて『Body』スプライトのsizeプロパティのY値を動的に変更し、視覚的な長さを調整するロジックを追加してください。」

---

## Chapter 8: 視覚的・聴覚的フィードバックプレイヤーのアクションに対して即座に明確なフィードバックを返すことは、ゲームの「手触り」や「楽しさ」を大きく左右する。ここでは、ノーツを叩いた時やミスした時のエフェクトと、UIによる情報表示を実装する。8.1. Unityエディタタスク：ヒット/ミスイベント用パーティクルエフェクトの作成Unityのパーティクルシステムは、炎、煙、爆発、魔法のエフェクトなど、無数の小さな画像を動かすことで複雑な視覚効果を生み出す強力なツールである。Hierarchyウィンドウで右クリックし、「Effects > Particle System」を選択して新しいパーティクルシステムを作成する。Inspectorウィンドウでパーティクルの設定を調整し、ノーツヒット時のきらびやかなエフェクトを作成する（例：短い生存期間、高い初期速度、発光するマテリアル）。このパーティクルシステムをHitEffectとしてプレハブ化する。プレハブ化する前に、Particle Systemコンポーネントの「Stop Action」を「Destroy」に設定しておく。これにより、再生が終了したエフェクトオブジェクトが自動的にシーンから破棄される。同様に、ミスした時の地味なエフェクト（例：煙が少し出るなど）を作成し、MissEffectとしてプレハブ化する。8.2. AIプロンプティング：動的フィードバックのトリガーをスクリプト化Vibe Codingタスク:コード スニペット`ScoreManager.cs`を修正してください。

以下のpublicなGameObject型のフィールドを追加します：
- `hitEffectPrefab`
- `missEffectPrefab`

`NoteHit()`メソッドを修正します。このメソッドは、ヒットしたノーツの位置を引数 (`Vector3 hitPosition`) で受け取るように変更してください。メソッド内で、`Instantiate`メソッドを使い、`hitEffectPrefab`を`hitPosition`の位置に生成してください。

同様に、`NoteMissed()`メソッドも、ミスしたノーツの位置を引数で受け取り、`missEffectPrefab`をその位置に生成するように修正してください。
この後、InputManagerとNoteControllerからScoreManagerのメソッドを呼び出す際に、ノーツのtransform.positionを渡すように修正する必要がある 70。8.3. UIの構築：TextMeshProによるスコアとコンボの表示Unityの標準UIテキストよりも高品質で多機能なテキストレンダリングを提供するTextMeshProは、現代のUnity開発において必須のツールとなっている 74。Unityエディタタスク:Hierarchyウィンドウで右クリックし、「UI > Canvas」を選択して、UI要素の親となるCanvasを作成する。Canvasの子として、「UI > Text - TextMeshPro」を2つ作成する。それぞれScoreText、ComboTextと命名する 74。Rect Transformツールを使い、それぞれのテキストを画面の適切な位置（例：右上と中央）に配置する。Vibe Codingタスク:コード スニペット`ScoreManager.cs`をさらに修正します。

まず、スクリプトの先頭に `using TMPro;` を追加してください。

次に、以下のpublicなフィールドを追加します：
- `scoreText`: スコアを表示するための `TextMeshProUGUI` への参照。
- `comboText`: コンボ数を表示するための `TextMeshProUGUI` への参照。

`NoteHit()`メソッドと`NoteMissed()`メソッドの最後に、スコアとコンボの値を更新した後に、対応するUIテキストの`.text`プロパティを更新する処理を追加してください。
例えば、`scoreText.text = "Score: " + score;` のようにします。コンボ数が0の場合はコンボ表示を消し、1以上の場合は表示するように制御すると、より洗練されます。
最後に、Unityエディタ上でScoreManagerコンポーネントのScore TextとCombo Textフィールドに、Hierarchyから対応するTextMeshProオブジェクトをドラッグ＆ドロップして関連付ける。Part IV: ファイナライズと配布ゲームのコアメカニクスと基本的なフィードバックが実装された最終パートでは、デモを一つの完成したアプリケーションとしてパッケージングする。これには、曲選択メニューの作成、シーン間でのデータ永続化、そして最終的なビルドと共有のプロセスが含まれる。Chapter 9: 曲選択メニューの作成9.1. AIプロンプティング：SongDataアセットをロードするMenuManagerゲームを開始する前に、プレイヤーがプレイしたい曲を選択できる画面が必要である。このメニューは、プロジェクト内に存在するすべてのSongDataアセットを動的に読み込み、選択肢として表示する必要がある。Vibe Codingタスク:コード スニペットUnity用のC#スクリプト「MenuManager」を作成してください。

このスクリプトは、`Resources`フォルダ内にあるすべての`SongData`アセットを読み込み、それぞれの曲を選択するためのUI要素を動的に生成する役割を持ちます。

`Start`メソッドで、`Resources.LoadAll<SongData>("")`を使用して、`Resources`フォルダとそのサブフォルダ内にあるすべての`SongData`アセットを配列として読み込んでください [77, 78, 79, 80]。

読み込んだ`SongData`アセットごとに、UIボタンを生成するロジックを実装してください。
ボタンのプレハブ (`buttonPrefab`) と、ボタンを配置する親のTransform (`contentParent`) への参照をpublicフィールドとして持たせてください。

生成した各ボタンには、対応する`SongData`の曲名を表示し、クリックされた際にその曲を選択してゲームシーンに遷移する処理を紐づけてください。
9.2. Unityエディタタスク：Scroll RectによるUIの構築曲数が多くなった場合でも対応できるよう、スクロール可能なリストとして曲選択UIを構築する。Unityエディタタスク:Assets/_Project/Scenes/に新しいシーンを作成し、MenuSceneと命名する。Hierarchyで「UI > Scroll View」を作成する。これにより、Scroll Rectコンポーネントを持つオブジェクトと、その子としてViewport、Content、Scrollbarが自動的に生成される。Contentオブジェクトに、「Add Component」から「Vertical Layout Group」を追加する。これにより、Contentの子オブジェクトが自動的に縦に整列される。曲選択ボタンのプレハブを作成する。「UI > Button - TextMeshPro」でボタンを作成し、デザインを整えた後、プレハブ化する。MenuManagerスクリプトを持つGameObjectをシーンに配置し、InspectorでbuttonPrefabとcontentParent（Scroll View内のContentオブジェクト）を割り当てる。9.3. シーン間のデータ永続化：GameManagerシングルトンMenuSceneで選択された曲の情報を、GameSceneに引き継ぐ必要がある。シーンが切り替わると、通常そのシーン内のすべてのGameObjectは破棄されてしまうため、シーンをまたいでデータを保持するための仕組みが必要となる。最も一般的な手法の一つが、DontDestroyOnLoadを使用したシングルトンパターンである 81。Vibe Codingタスク:コード スニペットシーン間でデータを永続化するためのC#スクリプト「GameManager」を作成してください。

このスクリプトは、シングルトンパターンを実装し、`DontDestroyOnLoad(gameObject)`を`Awake`メソッドで呼び出すことで、シーンが切り替わっても破棄されないようにしてください [82, 83, 84, 85]。
重複してインスタンスが生成されるのを防ぐため、`Awake`内で既に`instance`が存在する場合は自身を破棄するロジックも必ず含めてください。

`public SongData selectedSong;` というフィールドを追加してください。

`MenuManager`は、曲選択ボタンがクリックされた際に、`GameManager.instance.selectedSong`に選択された`SongData`を格納し、その後`SceneManager.LoadScene("GameScene")`を呼び出してシーンを遷移させます。
`GameScene`の`Conductor`スクリプトは、自身の`Start`メソッドで`GameManager.instance.selectedSong`を参照し、再生する曲を決定します。

この連携を実現するためのコードを実装してください。
このGameManagerは、ゲーム全体の状態管理や、シーン遷移のハブとして機能する、プロジェクトの重要な中心点となる。Chapter 10: ビルドと作品の共有10.1. スタンドアロンPCビルドのためのPlayerおよびBuild Settingsの設定Unityエディタタスク:メニューから「Edit > Project Settings」を開き、「Player」タブを選択する。「Company Name」と「Product Name」を入力する。これらは、実行ファイルのプロパティやインストール先のフォルダ名などに使用される。「Default Icon」セクションで、アプリケーションのアイコンとして使用したい画像ファイルを指定する 86。「Resolution and Presentation」セクションで、ゲームのデフォルトの起動設定を構成する 89。Fullscreen Mode: Fullscreen Window（ボーダーレスフルスクリーン）、Exclusive Fullscreen（排他的フルスクリーン、Windowsのみ）、Windowed（ウィンドウモード）から選択する 92。Default Screen Width/Height: ウィンドウモード時の初期解像度を設定する。10.2. ビルドプロセス：DevelopmentビルドとReleaseビルドUnityエディタタスク:メニューから「File > Build Settings」を開く。「Scenes In Build」セクションに、ビルドに含めるシーンを追加する。「Add Open Scenes」ボタンを使うか、Assets/_Project/Scenes/からMenuSceneとGameSceneをドラッグ＆ドロップする 94。シーンの順序が重要である。MenuSceneがリストの最上部（インデックス0）に来るようにドラッグして調整する。これにより、ゲーム起動時に最初にMenuSceneがロードされる。「Platform」リストから「PC, Mac & Linux Standalone」を選択し、「Target Platform」を「Windows」、「Architecture」を「x86_64」に設定する 97。ビルドには「Development Build」と「Release Build」の2種類がある 98。Development Build: デバッグ用のシンボル情報やプロファイラ接続機能が含まれる。テストやデバッグ目的で使用する 99。Release Build: （Development Buildのチェックを外した状態）不要なデバッグ情報が削除され、コードが最適化された、配布用のビルド。ファイルサイズが小さく、パフォーマンスが高い 98。今回は配布を想定し、「Development Build」のチェックを外した状態で「Build」ボタンをクリックする。ビルドの保存先フォルダを選択すると、Unityがビルド処理を開始する。完了すると、指定したフォルダに.exe実行ファイルと、リソースを含む_Dataフォルダが生成される 97。10.3. itch.ioへのデモアップロードガイド完成したデモを他者と共有する簡単な方法として、インディーゲームの配布プラットフォームであるitch.ioの利用が挙げられる。アカウント作成とプロジェクトページ: itch.ioでアカウントを作成し、「Upload new project」から新しいプロジェクトページを作成する 104。ビルドファイルの準備: Chapter 10.2で生成された.exeファイルと_Dataフォルダの両方を選択し、ZIP形式で圧縮する 102。アップロード: プロジェクト編集ページで、「Kind of project」を「Downloadable」に設定し、「Upload files」ボタンから作成したZIPファイルをアップロードする 105。ページ設定: ゲームのタイトル、説明、スクリーンショットなどを設定し、ページを公開する。価格は「No payments」に設定することで、無料でダウンロードできるようにできる 104。以上の手順で、UnityとClaude Codeを活用した4レーンリズムゲームデモの開発から配布までの一連のプロセスが完了する。結論本手順書では、Unity開発環境の専門的なセットアップから始まり、AIコーディングアシスタントClaudeを用いた「Vibe Coding」という先進的なワークフローを駆使して、4レーンのリズムゲームデモをゼロから構築するまでの全工程を詳細に解説した。このプロセスを通じて、現代のゲーム開発におけるいくつかの重要な原則が浮き彫りになった。第一に、プロジェクトの初期段階における基盤構築の重要性である。安定したLTSバージョンの選定、GitとGit LFSによる厳格なバージョン管理、そして論理的でスケーラブルなフォルダ構造の設計は、単なる準備作業ではなく、プロジェクト全体の健全性と将来の拡張性を保証するための不可欠な投資である。これらの基盤を疎かにすることは、後の開発フェーズで修正困難な技術的負債を生み出すことに直結する。第二に、AI支援開発、特に「Vibe Coding」の正しい活用法である。本手順書で示したように、AIは万能のコード生成機ではなく、開発者という指揮者の意図を理解し、その指示に基づいて実装を行う「協調的なパートナー」である。効果的な開発は、具体的で文脈を伴ったプロンプトエンジニアリング、AIが生成したコードに対する厳密なレビュー、そしてシステム間の連携を設計するアーキテクトとしての開発者の役割によって成り立つ。このワークフローは、開発者を単純なコーディング作業から解放し、より創造的で設計的なタスクに集中させることを可能にする。第三に、リズムゲームというジャンル特有の技術的要件への深い理解の必要性である。特に、AudioSettings.dspTimeをタイミングの絶対的な基準として用いることは、プレイフィールを決定づけるノンネゴシエータブルな要素である。この選択は、フレームレートの変動から完全に独立した、サンプル精度の同期を実現するための唯一の正しいアプローチであり、この知識の有無が、プロフェッショナルなリズムゲームとアマチュアの作品とを分ける一線となる。最終的に、本手順書は単一のデモ作成ガイドにとどまらず、現代的なツールと方法論を統合した、一つの体系的な開発パラダイムを提示するものである。ScriptableObjectによるデータ駆動設計、プレハブによる再利用性の確保、シングルトンによる状態管理といったUnityのベストプラクティスと、Vibe Codingという新しい開発スタイルを融合させることで、開発者はアイデアの着想からプロトタイプの具現化、そして最終的な製品化までのサイクルを、かつてない速度と品質で実行することが可能となる。今後の展望として、このワークフローはさらに洗練されていくだろう。Unity公式のAIツール（Unity MuseやUnity Sentis）の進化や、より高度なAIモデルの登場により、AIはコード生成だけでなく、アセット作成、レベルデザイン、デバッグ、最適化といった、開発のあらゆる側面で開発者を支援するようになることが期待される。その未来において、本手順書で概説したような、AIと協調し、その能力を最大限に引き出すための基礎的なスキルと設計思想は、すべての開発者にとってますます重要なものとなるであろう。